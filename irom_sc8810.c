/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void reset();
void *sub_FFFF0038();
void __fastcall __noreturn die(int a1, int a2);
int __fastcall jump_to(int a1);
int *__noreturn irom_enter();
int *__fastcall sub_FFFF00B0(int *result, int *a2, unsigned int a3);
void sub_FFFF00E8();
void null_1();
void __noreturn sub_FFFF00F4();
void __fastcall __noreturn empty(int a1, int a2);
signed int sub_FFFF0114();
signed int sub_FFFF0118();
int __fastcall sub_FFFF0124(_BYTE *a1, int a2);
int __fastcall sub_FFFF0160(unsigned int a1);
signed int __fastcall usb_download_related(int a1, int a2, int a3, int a4);
signed int __fastcall sub_FFFF01FC(_DWORD *a1, _DWORD *a2, int a3, int a4);
void __fastcall __noreturn maybe_usb_download(int a1, int a2, unsigned __int16 *a3, int a4);
int __fastcall maybe_usb_download_related(int a1, int a2, int a3, int a4);
int sub_FFFF02DC();
int __fastcall sub_FFFF02FE(int a1);
int __fastcall sub_FFFF0322(int a1);
int sub_FFFF0350();
int sub_FFFF036A();
int __fastcall sub_FFFF0388(int a1);
signed int sub_FFFF03DC();
int __fastcall maybe_usb_download_related_2(int a1);
int __fastcall usb_endpoint_related(int a1, int a2);
signed int __fastcall sub_FFFF0496(char a1, char a2, int a3, int a4);
_DWORD *__fastcall sub_FFFF04D0(int a1, int a2);
unsigned int *__fastcall sub_FFFF04FA(int a1, char a2, int a3, __int16 a4);
_DWORD *__fastcall sub_FFFF0524(int a1, int a2, int a3, int a4, int a5);
int __fastcall sub_FFFF05C4(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5);
_DWORD *__fastcall sub_FFFF0604(char a1);
_DWORD *__fastcall sub_FFFF0638(int a1, int a2, int a3, int a4);
int usb_reset_handler();
int usb_enumeration_done();
unsigned int sub_FFFF07E8();
int __fastcall sub_FFFF08C4(int a1, int a2, int a3, int a4);
int __fastcall usb_EP_out_handle(int a1, int a2, int a3, int a4);
signed int maybe_some_usb_interrupts_1();
int __fastcall usb_handler(int a1, int a2, int a3, int a4);
int __fastcall sub_FFFF09A6(int a1, int a2, int a3);
int __fastcall usb_core_init(int a1);
int __fastcall maybe_usb_read(_BYTE *a1);
unsigned int sub_FFFF0AF0();
unsigned int __fastcall sub_FFFF0BCA(_DWORD *a1);
int sub_FFFF0BEE();
signed int *__fastcall sub_FFFF0C1E(unsigned __int8 *a1, int a2);
signed int __fastcall sub_FFFF0C64(_DWORD *a1, _DWORD *a2);
_DWORD *__fastcall uart_setup(_DWORD *result);
int __fastcall sub_FFFF0CA6(unsigned __int8 *a1, int a2);
BOOL sub_FFFF0CD8();
unsigned int __fastcall sub_FFFF0D34(int a1);
int __fastcall sub_FFFF0DA0(int a1);
int sub_FFFF0E18();
BOOL __fastcall select_mmc(int a1);
unsigned int __fastcall sub_FFFF0F44(int a1);
signed int __fastcall sub_FFFF0F74(int a1, int a2);
signed int sub_FFFF1020();
BOOL sub_FFFF10C4();
signed int read_spl_from_emmc();
signed int maybe_clock_init();
signed int sub_FFFF11EA();
signed int sub_FFFF1238();
_DWORD *uart_init();
int keypad_init();
int sub_FFFF12C0();
signed int disable_keypad();
int get_timer_tick();
signed int __fastcall sub_FFFF131C(_DWORD *a1, int a2);
signed int __fastcall sub_FFFF1348(int a1);
int sub_FFFF1370();
int __fastcall trace_write(int result);
int platform_init();
unsigned int sleep();
BOOL read_unknown_ctrl5_1();
BOOL maybe_if_allow_uart_download();
signed int sub_FFFF13F6();
int CheckSecureBootEnable();
signed int __fastcall maybe_USB_LDO_Control(int a1);
signed int sub_FFFF146C();
signed int __fastcall HashVerify(int a1, int a2);
int maybe_check_usb_download();
BOOL read_unknown_ctrl5_3();
int __fastcall sub_FFFF1516(int a1);
BOOL is_booting_from_emmc();
BOOL read_unknown_ctrl5_4();
BOOL read_unknown_ctrl5_2();
int __fastcall sub_FFFF1556(int a1, int a2, int a3);
signed int sub_FFFF1610();
int __fastcall sub_FFFF163A(int a1);
int __fastcall sub_FFFF1684(int a1, int a2, int a3, unsigned int a4);
int __fastcall sub_FFFF1688(int result, unsigned __int8 a2, unsigned int a3);
int __fastcall sub_FFFF1692(unsigned __int16 *a1, signed int a2);
signed int nand_stuffs_1();
signed int disable_nfc();
signed int sub_FFFF176E();
signed int __fastcall sub_FFFF17C8(int a1);
signed int __fastcall sub_FFFF17EA(unsigned __int8 *a1);
signed int __fastcall sub_FFFF1812(unsigned __int8 *a1, int a2);
signed int __fastcall sub_FFFF18EC(unsigned __int16 *a1);
signed int __fastcall sub_FFFF1940(unsigned __int8 *a1, int a2);
signed int *__fastcall sub_FFFF19D4(unsigned int a1);
void __fastcall __noreturn sub_FFFF19F0(int a1, int a2, unsigned __int16 *a3, int a4);
int __fastcall detect_uart_download(int a1, int *a2, _BYTE *a3);
unsigned int __fastcall check_uart_download(int a1);
signed int __fastcall sub_FFFF1B5C(int a1);
signed int __fastcall sub_FFFF1B8C(int a1, int a2, int a3, unsigned int a4);
int __fastcall sub_FFFF1BCC(_BYTE *a1, int a2, unsigned int a3);
signed int __fastcall sub_FFFF1C84(unsigned __int8 *a1, int a2, int a3);
signed int __fastcall nand_stuffs_2(int a1);
signed int clear_uart_fifo();
signed int __fastcall read_spl_from_nand(int a1, int a2, int a3, int a4);
int __cdecl main();
int sub_FFFF1EEE();
signed int *__fastcall sub_FFFF1F12(int a1);
signed int *__fastcall sub_FFFF1F36(int a1);
signed int *sub_FFFF1F64();
int __fastcall sub_FFFF1F7E(int a1, int a2);
signed int sub_FFFF1F94();
int __fastcall sub_FFFF1FA0(_BYTE *a1, unsigned int a2);
int __fastcall sub_FFFF1FD0(int a1, int a2, int a3, unsigned int a4);
int __fastcall sub_FFFF1FD4(int result, int a2, unsigned int a3, unsigned int a4);
_DWORD *__fastcall sub_FFFF20A8(_DWORD *result, int *a2, unsigned int a3, int a4);
void __fastcall sub_FFFF21AC(unsigned int a1, unsigned int a2);
_DWORD *__fastcall sub_FFFF22E0(_DWORD *result, unsigned int a2, int a3);
void *sub_FFFF232A();
void *sub_FFFF2380();
void *sub_FFFF2388();
int __fastcall sub_FFFF2390(unsigned int a1, unsigned int a2);
int __fastcall jump_to(int a1);
unsigned int __fastcall sub_FFFF23BC(unsigned int a1);
unsigned int __fastcall sub_FFFF23C4(int a1);
_DWORD *sub_FFFF23D8();
_DWORD *__fastcall sub_FFFF2484(_DWORD *a1, int a2, int a3, int a4);
_DWORD *__fastcall sub_FFFF2528(_DWORD *a1, unsigned int *a2, int a3);
unsigned int __fastcall sub_FFFF25C8(unsigned int result);
int __fastcall RSA_ModPower(int result, _DWORD *a2, int a3, int a4);
_DWORD *__fastcall MD5Init(_DWORD *result);
int __fastcall sub_FFFF2714(int *a1, int *a2);
int __fastcall sub_FFFF3108(int result, int a2, int *a3);
int __fastcall MD5Final(int *a1, unsigned int a2, int a3);
int efuse_get_timer_tick();
int efuse_parameter_config_1();
unsigned int efuse_parameter_config_2();
signed int __fastcall efuse_read(unsigned int a1, _DWORD *a2);
signed int __fastcall sub_FFFF32EE(unsigned int a1, int a2, int a3, int a4);
int __fastcall efuse_program_related(unsigned int a1, int a2, int a3, int a4);
signed int __fastcall sub_FFFF33BE(unsigned int a1, int a2, int a3, int a4);
signed int __fastcall sub_FFFF33E4(int a1, int a2, int a3, int a4);
int __fastcall sub_FFFF33FA(int a1);
int __fastcall sub_FFFF3416(_DWORD *a1, int a2, int a3, int a4);
signed int __fastcall sub_FFFF3436(unsigned int a1, bool *a2);
int __fastcall sub_FFFF3460(unsigned int *a1, int *a2);
_DWORD *__fastcall sub_FFFF34A8(_DWORD *result, unsigned int *a2, unsigned int a3);

//-------------------------------------------------------------------------
// Data declarations

int dword_40000020; // weak
int dword_40000024; // weak
_UNKNOWN unk_40000028; // weak
int g_TraceValue; // weak
int dword_40006004; // weak
int dword_40006008; // weak
int mmc_selected; // weak
int dword_40006010; // weak
int dword_40006014; // weak
int dword_40006018; // weak
int dword_4000601C; // weak
_UNKNOWN unk_40006020; // weak
_UNKNOWN unk_4000605C; // weak
int dword_40006114; // weak
int dword_4000611C; // weak
int dword_40006120; // weak
int dword_40006124; // weak
int dword_40006128; // weak
int dword_40006130; // weak
int dword_40006134; // weak
_BYTE byte_40006150[256]; // idb
int dword_40006250; // weak
int dword_40006254; // weak
unsigned __int8 byte_40006258[1024]; // idb
int efuse_hash_data[]; // weak
int dword_4000665C; // weak
int dword_40006660; // weak
int dword_40006664; // weak
int soft_hash_data[]; // weak
int dword_4000666C; // weak
int dword_40006670; // weak
int dword_40006674; // weak
_UNKNOWN unk_4000667C; // weak
_UNKNOWN INIT_STACK; // weak
_UNKNOWN unk_40007A8C; // weak
__int16 word_40007E8C; // weak
char byte_40007E90; // weak
int dword_40007E94; // weak
int dword_40007E98; // weak
int dword_40007E9C; // weak
int dword_40007EA0; // weak
int dword_40007EA4; // weak
int dword_40007EA8; // weak
int dword_40007EAC; // weak
_UNKNOWN unk_40007EB0; // weak
int dword_40007EB4; // weak
int dword_40007EB8; // weak
int dword_40007EBC; // weak
_UNKNOWN unk_40007EC4; // weak
_UNKNOWN unk_40007EC8; // weak
_UNKNOWN loc_FFFF21CC; // weak
_UNKNOWN loc_FFFF220C; // weak
_UNKNOWN loc_FFFF223C; // weak
void (__fastcall *off_FFFF2440[5])(unsigned __int16 *, int) =
{
  (void (__fastcall *)(unsigned __int16 *, int))0xFFFF1EF1,
  (void (__fastcall *)(unsigned __int16 *, int))0xFFFF1F15,
  (void (__fastcall *)(unsigned __int16 *, int))0xFFFF1F39,
  (void (__fastcall *)(unsigned __int16 *, int))0xFFFF1F65,
  (void (__fastcall *)(unsigned __int16 *, int))0xFFFF1F81
}; // idb
void *off_FFFF2454 = &unk_FFFF3508; // weak
_UNKNOWN unk_FFFF3508; // weak


//----- (FFFF0000) --------------------------------------------------------
void reset()
{
  __set_CPSR(0xD3u);                            // Switch to SVC mode
  irom_enter();
}

//----- (FFFF0038) --------------------------------------------------------
void *sub_FFFF0038()
{
  return &unk_4000667C;
}

//----- (FFFF007C) --------------------------------------------------------
int *__noreturn irom_enter()
{
  if ( &off_FFFF2454 == (void **)sub_FFFF2484 )
    sub_FFFF00F4();
  return (int *)sub_FFFF00B0((int *)&unk_FFFF3508, &g_TraceValue, 4u);
}
// 40006000: using guessed type int g_TraceValue;
// FFFF2454: using guessed type void *off_FFFF2454;

//----- (FFFF00B0) --------------------------------------------------------
int *__fastcall sub_FFFF00B0(int *result, int *a2, unsigned int a3)
{
  bool v3; // cf
  int v4; // r3
  int v5; // r4
  int v6; // r5
  int v7; // r6
  signed int v8; // r2
  int v9; // r4
  int v10; // r5

  do
  {
    v3 = a3 >= 0x10;
    a3 -= 16;
    if ( v3 )
    {
      v4 = *result;
      v5 = result[1];
      v6 = result[2];
      v7 = result[3];
      result += 4;
      *a2 = v4;
      a2[1] = v5;
      a2[2] = v6;
      a2[3] = v7;
      a2 += 4;
    }
  }
  while ( a3 != 0 && v3 );
  v3 = __CFSHL__(a3, 29);
  v8 = a3 << 29;
  if ( v3 )
  {
    v9 = *result;
    v10 = result[1];
    result += 2;
    *a2 = v9;
    a2[1] = v10;
    a2 += 2;
  }
  if ( v8 < 0 )
    *a2 = *result;
  return result;
}

//----- (FFFF00E8) --------------------------------------------------------
void sub_FFFF00E8()
{
  sub_FFFF23D8();
}

//----- (FFFF00F0) --------------------------------------------------------
void null_1()
{
  ;
}

//----- (FFFF00F4) --------------------------------------------------------
void __noreturn sub_FFFF00F4()
{
  int v0; // r0
  int v1; // r1

  sub_FFFF232A();
  sub_FFFF00E8();
  v0 = main();
  empty(v0, v1);
}

//----- (FFFF0106) --------------------------------------------------------
void __fastcall __noreturn empty(int a1, int a2)
{
  int v2; // [sp+0h] [bp-8h]
  int v3; // [sp+4h] [bp-4h]

  v2 = a1;
  v3 = a2;
  null_1();
  die(v2, v3);
}

//----- (FFFF0114) --------------------------------------------------------
signed int sub_FFFF0114()
{
  return 0xFFFF23E8;
}

//----- (FFFF0118) --------------------------------------------------------
signed int sub_FFFF0118()
{
  return 0xFFFF23FC;
}

//----- (FFFF0124) --------------------------------------------------------
int __fastcall sub_FFFF0124(_BYTE *a1, int a2)
{
  int v2; // r5
  _BYTE *v3; // r4
  __int16 v4; // r0
  int v5; // r1

  v2 = a2;
  v3 = a1;
  v4 = sub_FFFF1FA0(a1, a2 - 2);
  v3[v2 - 2] = HIBYTE(v4);
  v3[v2 - 1] = v4;
  v5 = v2 + 2;
  v3[v2] = 0x7E;
  while ( v5 > 0 )
  {
    v3[v5] = v3[v5 - 1];
    --v5;
  }
  *v3 = 0x7E;
  return sub_FFFF09A6(5, (int)v3, v2 + 2);
}

//----- (FFFF0160) --------------------------------------------------------
int __fastcall sub_FFFF0160(unsigned int a1)
{
  __int16 v1; // r1
  int v2; // r0

  v1 = sub_FFFF23BC(a1);
  v2 = dword_40006018;
  *(_WORD *)dword_40006018 = v1;
  *(_WORD *)(v2 + 2) = 0;
  return sub_FFFF0124((_BYTE *)v2, 6);
}
// 40006018: using guessed type int dword_40006018;

//----- (FFFF017C) --------------------------------------------------------
signed int __fastcall usb_download_related(int a1, int a2, int a3, int a4)
{
  int v4; // r0
  int v5; // r1
  signed int result; // r0
  int v7; // r1
  int v8; // [sp+0h] [bp-18h]

  v8 = a4;
  LOBYTE(v8) = 0;
  while ( 1 )
  {
    result = dword_40006114;
    if ( dword_40006114 == 3 )
      break;
    while ( 1 )
    {
      while ( 1 )
      {
        v4 = maybe_usb_read(&v8);
        if ( dword_40006114 )
          break;
        if ( v4 == 0x7E )
          dword_40006114 = 1;
      }
      if ( dword_40006114 != 1 )
        break;
      if ( v4 != 0x7E )
      {
        if ( v4 == 0x7D )
          LOBYTE(v4) = maybe_usb_read(&v8) ^ 0x20;
        dword_40006114 = 2;
        v5 = dword_40006128;
        *(_BYTE *)dword_40006128 = v4;
        dword_40006128 = v5 + 1;
        ++dword_40006120;
      }
    }
    if ( dword_40006114 == 2 )
    {
      if ( v4 == 0x7E )
      {
        result = 3;
        dword_40006114 = 3;
        return result;
      }
      if ( v4 == 0x7D )
        LOBYTE(v4) = maybe_usb_read(&v8) ^ 0x20;
      v7 = dword_40006128;
      *(_BYTE *)dword_40006128 = v4;
      dword_40006128 = v7 + 1;
      ++dword_40006120;
    }
  }
  return result;
}
// 40006114: using guessed type int dword_40006114;
// 40006120: using guessed type int dword_40006120;
// 40006128: using guessed type int dword_40006128;

//----- (FFFF01FC) --------------------------------------------------------
signed int __fastcall sub_FFFF01FC(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  _DWORD *v4; // r5
  _DWORD *v5; // r6

  v4 = a1;
  v5 = a2;
  dword_40006120 = 0;
  dword_40006128 = dword_40006124;
  dword_40006114 = 0;
  usb_download_related(0, dword_40006124, a3, a4);
  if ( sub_FFFF1FA0((_BYTE *)dword_40006124, dword_40006120) )
    return 139;
  *v4 = dword_40006124;
  *v5 = dword_40006120;
  return 143;
}
// 40006114: using guessed type int dword_40006114;
// 40006120: using guessed type int dword_40006120;
// 40006124: using guessed type int dword_40006124;
// 40006128: using guessed type int dword_40006128;

//----- (FFFF022C) --------------------------------------------------------
void __fastcall __noreturn maybe_usb_download(int a1, int a2, unsigned __int16 *a3, int a4)
{
  signed int v4; // r0
  unsigned int v5; // r0
  unsigned __int16 *v6; // [sp+0h] [bp-10h]
  int v7; // [sp+4h] [bp-Ch]

  v6 = a3;
  v7 = a4;
  while ( 1 )
  {
    v4 = sub_FFFF01FC(&v6, &v7, (int)a3, a4);
    if ( v4 == 143 )
    {
      v5 = sub_FFFF23BC(*v6);
      (*(void (__fastcall **)(unsigned __int16 *, int))(4 * v5 - 56292))(v6, v7);
    }
    else
    {
      sub_FFFF0160(v4);
      sub_FFFF1688((int)&word_40007E8C, 0, 0x18u);
    }
  }
}
// 40007E8C: using guessed type __int16 word_40007E8C;

//----- (FFFF0260) --------------------------------------------------------
int __fastcall maybe_usb_download_related(int a1, int a2, int a3, int a4)
{
  __int16 v4; // r0
  unsigned __int16 v5; // r0
  __int16 v6; // r0
  int v7; // r0
  unsigned int v8; // r3
  signed int v9; // r0
  int v10; // r0
  int v11; // r1
  unsigned __int16 *v12; // r2
  int v13; // r3
  int v15; // [sp+0h] [bp-18h]

  v15 = a4;
  LOBYTE(v15) = 0;
  dword_40006018 = (int)&INIT_STACK;
  dword_4000601C = (int)&unk_40007A8C;
  dword_4000611C = 1024;
  dword_40006124 = (int)&unk_40007A8C;
  dword_40006250 = 0;
  dword_40006254 = 0;
  do
  {
    if ( maybe_usb_read(&v15) == 0x7E && !(_BYTE)v15 )
    {
      v4 = sub_FFFF23BC(0x81u);
      *(_WORD *)dword_40006018 = v4;
      v5 = sub_FFFF1F94();
      v6 = sub_FFFF23BC(v5);
      *(_WORD *)(dword_40006018 + 2) = v6;
      v7 = sub_FFFF1F94();
      sub_FFFF1684(dword_40006018 + 4, (int)"SPRD3", v7, v8);
      v9 = sub_FFFF1F94();
      v10 = sub_FFFF0124((_BYTE *)dword_40006018, v9 + 6);
      maybe_usb_download(v10, v11, v12, v13);
    }
  }
  while ( (unsigned __int8)v15 != 1 );
  return (unsigned __int8)v15;
}
// 40006018: using guessed type int dword_40006018;
// 4000601C: using guessed type int dword_4000601C;
// 4000611C: using guessed type int dword_4000611C;
// 40006124: using guessed type int dword_40006124;
// 40006250: using guessed type int dword_40006250;
// 40006254: using guessed type int dword_40006254;

//----- (FFFF02DC) --------------------------------------------------------
int sub_FFFF02DC()
{
  if ( byte_40007E90 != 1 )
  {
    sub_FFFF0160(0x80u);
    byte_40007E90 = 1;
  }
  return sub_FFFF1688((int)&word_40007E8C, 0, 0x18u);
}
// 40007E8C: using guessed type __int16 word_40007E8C;
// 40007E90: using guessed type char byte_40007E90;

//----- (FFFF02FE) --------------------------------------------------------
int __fastcall sub_FFFF02FE(int a1)
{
  int v1; // r5
  unsigned int v2; // r4
  unsigned int v3; // r0

  v1 = a1;
  v2 = sub_FFFF23C4(*(_DWORD *)(a1 + 4));
  v3 = sub_FFFF23C4(*(_DWORD *)(v1 + 8));
  dword_40007E9C = v2;
  dword_40007EA0 = v2;
  dword_40007E94 = v3;
  return sub_FFFF0160(0x80u);
}
// 40007E94: using guessed type int dword_40007E94;
// 40007E9C: using guessed type int dword_40007E9C;
// 40007EA0: using guessed type int dword_40007EA0;

//----- (FFFF0322) --------------------------------------------------------
int __fastcall sub_FFFF0322(int a1)
{
  int v1; // r5
  int v2; // r6
  unsigned int v3; // r3

  v1 = a1;
  v2 = sub_FFFF23BC(*(unsigned __int16 *)(a1 + 2));
  sub_FFFF1684(dword_40007EA0, v1 + 4, v2, v3);
  dword_40007EA0 += v2;
  dword_40007E98 += v2;
  return sub_FFFF0160(0x80u);
}
// 40007E98: using guessed type int dword_40007E98;
// 40007EA0: using guessed type int dword_40007EA0;

//----- (FFFF0350) --------------------------------------------------------
int sub_FFFF0350()
{
  unsigned int v0; // r0

  if ( dword_40007E98 == dword_40007E94 )
  {
    word_40007E8C = 143;
    v0 = 128;
  }
  else
  {
    byte_40007E90 = 5;
    v0 = 139;
  }
  return sub_FFFF0160(v0);
}
// 40007E8C: using guessed type __int16 word_40007E8C;
// 40007E90: using guessed type char byte_40007E90;
// 40007E94: using guessed type int dword_40007E94;
// 40007E98: using guessed type int dword_40007E98;

//----- (FFFF036A) --------------------------------------------------------
int sub_FFFF036A()
{
  sub_FFFF0160(0x80u);
  sleep();
  return jump_to(dword_40007E9C);
}
// 40007E9C: using guessed type int dword_40007E9C;

//----- (FFFF0388) --------------------------------------------------------
int __fastcall sub_FFFF0388(int a1)
{
  MEMORY[0x2090020C] &= 0xFFFFFFFB;
  MEMORY[0x20900200] |= 0x20u;
  maybe_USB_LDO_Control(1);
  sub_FFFF146C();
  MEMORY[0x20900210] |= 0x80u;
  sleep();
  MEMORY[0x20900210] &= 0xFFFFFF7F;
  MEMORY[0x8B000020] |= 0x5A00u;
  sleep();
  return usb_core_init(a1);
}

//----- (FFFF03DC) --------------------------------------------------------
signed int sub_FFFF03DC()
{
  signed int result; // r0
  unsigned int v1; // r1
  unsigned int v2; // r1

  result = 0x20900000;
  v1 = 0;
  MEMORY[0x20900224] |= 3u;
  do
    ++v1;
  while ( v1 < 0xA );
  v2 = 0;
  MEMORY[0x20900224] |= 0x30u;
  do
    ++v2;
  while ( v2 < 0xA );
  MEMORY[0x20900224] &= 0xFE7FFFFF;
  return result;
}

//----- (FFFF0414) --------------------------------------------------------
int __fastcall maybe_usb_download_related_2(int a1)
{
  int v2; // r1
  int v3; // r2
  int v4; // r3
  int result; // r0

  sub_FFFF03DC();
  sub_FFFF0388(a1);
  trace_write(2);
  result = maybe_usb_download_related(1, v2, v3, v4);
  if ( result != 1 )
  {
    while ( 1 )
      ;
  }
  return result;
}

//----- (FFFF0464) --------------------------------------------------------
int __fastcall usb_endpoint_related(int a1, int a2)
{
  MEMORY[0x20300B10] |= 0x60000000u;
  MEMORY[0x20300B10] |= 0x18u;
  if ( a1 )
    MEMORY[0x20300B14] = a2;
  MEMORY[0x20300B00] |= 0x4000000u;
  MEMORY[0x20300B00] |= 0x80000000;
  return 0;
}

//----- (FFFF0496) --------------------------------------------------------
signed int __fastcall sub_FFFF0496(char a1, char a2, int a3, int a4)
{
  signed int result; // r0

  MEMORY[0x20300910] = (MEMORY[0x20300910] & 0xFFFFFF80 | a1 & 0x7F) & 0xFFE7FFFF | ((a2 & 3) << 19);
  if ( a3 )
    MEMORY[0x20300914] = a4;
  result = 540018944;
  MEMORY[0x20300900] &= 0xFC3FFFFF;
  MEMORY[0x20300900] |= 0x4000000u;
  MEMORY[0x20300900] |= 0x80000000;
  return result;
}

//----- (FFFF04D0) --------------------------------------------------------
_DWORD *__fastcall sub_FFFF04D0(int a1, int a2)
{
  signed int v2; // r2
  signed int v3; // r1
  signed int *v4; // r3
  _DWORD *result; // r0

  if ( a2 )
  {
    v2 = 12296;
    v3 = 540019456;
    v4 = (signed int *)540018708;
  }
  else
  {
    v2 = -1;
    v4 = (signed int *)540018704;
    v3 = 540018944;
  }
  result = (_DWORD *)(v3 + 32 * a1);
  *result |= 0x8000u;
  *v4 = v2;
  return result;
}

//----- (FFFF04FA) --------------------------------------------------------
unsigned int *__fastcall sub_FFFF04FA(int a1, char a2, int a3, __int16 a4)
{
  signed int v4; // r2
  unsigned int *result; // r0

  if ( a3 )
    v4 = 540019456;
  else
    v4 = 540018944;
  result = (unsigned int *)(v4 + 32 * a1);
  *result = *result & 0xFFF3FFFF | ((a2 & 3) << 18);
  *result = *result & 0xFFFFF800 | a4 & 0x7FF;
  *result |= 0x8000000u;
  return result;
}

//----- (FFFF0524) --------------------------------------------------------
_DWORD *__fastcall sub_FFFF0524(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // r4
  _DWORD *result; // r0

  v5 = a1;
  if ( a2 )
  {
    if ( a4 )
      *(_DWORD *)(32 * a1 + 0x20300B14) = a5;
    *(_DWORD *)(32 * a1 + 0x20300B10) = (*(_DWORD *)(32 * a1 + 0x20300B10) >> 19 << 19) + 256;
    result = (_DWORD *)(32 * a1 + 540019456);
    *(_DWORD *)(32 * v5 + 0x20300B10) = *(_DWORD *)(32 * v5 + 0x20300B10) & 0xE007FFFF | 0x80000;
    *result = *(_DWORD *)(32 * v5 + 0x20300B00) | 0x4000000;
    *result = *(_DWORD *)(32 * v5 + 0x20300B00) | 0x80000000;
  }
  else
  {
    if ( a4 )
      *(_DWORD *)(32 * a1 + 0x20300914) = a5;
    *(_DWORD *)(32 * a1 + 0x20300910) = *(_DWORD *)(32 * a1 + 0x20300910) & 0xFFF80000 | a3 & 0x7FFFF;
    *(_DWORD *)(32 * a1 + 0x20300910) = *(_DWORD *)(32 * a1 + 0x20300910) & 0xE007FFFF | ((sub_FFFF2390(
                                                                                             (*(_DWORD *)(32 * a1 + 0x20300900) & 0x7FF)
                                                                                           + a3
                                                                                           - 1,
                                                                                             *(_DWORD *)(32 * a1 + 0x20300900) & 0x7FF) & 0x3FF) << 19);
    *(_DWORD *)(32 * v5 + 0x20300900) = *(_DWORD *)(32 * v5 + 0x20300900) & 0xFC3FFFFF | ((v5 & 0xF) << 22);
    *(_DWORD *)(32 * v5 + 0x20300900) |= 0x4000000u;
    result = (_DWORD *)(*(_DWORD *)(32 * v5 + 0x20300900) | 0x80000000);
    *(_DWORD *)(32 * v5 + 0x20300900) = result;
  }
  return result;
}

//----- (FFFF05C4) --------------------------------------------------------
int __fastcall sub_FFFF05C4(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5)
{
  int v5; // r4
  int result; // r0
  int v7; // r3
  char v8; // r0

  v5 = (*a2 >> 16) & 0xFF;
  result = *a1 >> 24;
  if ( result == 1 )
  {
    v7 = sub_FFFF0114();
    v8 = 18;
  }
  else
  {
    if ( result != 2 )
      return result;
    v7 = sub_FFFF0118();
    if ( v5 == 255 )
      v8 = 32;
    else
      v8 = v5;
  }
  return sub_FFFF0496(v8, 1, 1, v7);
}

//----- (FFFF0604) --------------------------------------------------------
_DWORD *__fastcall sub_FFFF0604(char a1)
{
  char v1; // r5
  int v2; // r4
  _DWORD *result; // r0
  signed int v4; // r0

  v1 = a1;
  v2 = a1 & 0x7F;
  result = (_DWORD *)sub_FFFF0496(0, 1, 0, 0);
  if ( v2 )
  {
    if ( v1 & 0x80 )
      v4 = 540018944;
    else
      v4 = 540019456;
    result = (_DWORD *)(v4 + 32 * v2);
    *result |= 0x10000000u;
  }
  return result;
}

//----- (FFFF0638) --------------------------------------------------------
_DWORD *__fastcall sub_FFFF0638(int a1, int a2, int a3, int a4)
{
  unsigned int v4; // r2
  int v5; // r2
  _DWORD *result; // r0
  int v7; // r2
  int *v8; // r3
  char v9; // r0
  int v10; // [sp+0h] [bp-8h]

  v10 = 0;
  v4 = ((unsigned int)dword_40006130 >> 5) & 3;
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      if ( v4 == 2 )
      {
        v7 = 1;
        v8 = &v10;
        v9 = 4;
        return (_DWORD *)sub_FFFF0496(v9, 1, v7, (int)v8);
      }
      goto LABEL_19;
    }
    if ( (dword_40006130 & 0x1F) != 1 )
    {
LABEL_19:
      v8 = 0;
      goto LABEL_10;
    }
    if ( (((unsigned int)dword_40006130 >> 16) & 0xFF) == 1 && (unsigned int)dword_40006130 >> 24 == 6 )
    {
      sub_FFFF04D0(5, 0);
      sub_FFFF04D0(6, 1);
    }
LABEL_14:
    v8 = 0;
    v7 = 0;
    goto LABEL_15;
  }
  v5 = (unsigned __int16)dword_40006130 >> 8;
  switch ( v5 )
  {
    case 1:
      result = (_DWORD *)(dword_40006130 & 0x1F);
      if ( result == (_DWORD *)2 )
        result = sub_FFFF0604(dword_40006134);
      break;
    case 5:
      MEMORY[0x20300800] = MEMORY[0x20300800] & 0xFFFFF80F | 16 * (((unsigned int)dword_40006130 >> 16) & 0x7F);
      goto LABEL_14;
    case 6:
      result = (_DWORD *)sub_FFFF05C4(&dword_40006130, &dword_40006134, 6, a4, v10);
      break;
    case 9:
      goto LABEL_14;
    default:
      v8 = &v10;
LABEL_10:
      v7 = 1;
LABEL_15:
      v9 = 0;
      return (_DWORD *)sub_FFFF0496(v9, 1, v7, (int)v8);
  }
  return result;
}
// 40006130: using guessed type int dword_40006130;
// 40006134: using guessed type int dword_40006134;

//----- (FFFF06EC) --------------------------------------------------------
int usb_reset_handler()
{
  unsigned int v0; // r0
  unsigned int v1; // r0
  int result; // r0

  MEMORY[0x20300018] &= 0xFFFFEFFF;
  MEMORY[0x20300B00] |= 0x8000000u;
  MEMORY[0x20300BC0] |= 0x8000000u;
  MEMORY[0x2030081C] |= 0x10001u;
  MEMORY[0x20300814] |= 0xFu;
  v0 = 0;
  MEMORY[0x20300810] |= 0x2Fu;
  MEMORY[0x20300024] = 0x214;
  MEMORY[0x20300028] = 0x200214;
  MEMORY[0x20300114] = 0x800234;
  MEMORY[0x20300010] |= 0x20u;
  do
  {
    if ( !(MEMORY[0x20300010] & 0x20) )
      break;
    ++v0;
  }
  while ( v0 < 0x3E80 );
  v1 = 0;
  MEMORY[0x20300010] |= 0x10u;
  do
  {
    if ( !(MEMORY[0x20300010] & 0x10) )
      break;
    ++v1;
  }
  while ( v1 < 0x3E80 );
  usb_endpoint_related(1, (int)&dword_40006130);
  MEMORY[0x20300018] |= 0x1000u;
  result = MEMORY[0x20300014] | 0x1000;
  MEMORY[0x20300014] |= 0x1000u;
  return result;
}
// 40006130: using guessed type int dword_40006130;

//----- (FFFF0794) --------------------------------------------------------
int usb_enumeration_done()
{
  int result; // r0

  dword_40006004 = (MEMORY[0x20300808] >> 1) & 3;
  MEMORY[0x20300900] &= 0xFFFFFFFC;
  sub_FFFF04FA(5, 2, 0, 64);
  sub_FFFF04FA(6, 2, 1, 64);
  usb_endpoint_related(1, (int)&dword_40006130);
  MEMORY[0x20300804] |= 0x100u;
  result = MEMORY[0x20300014] | 0x2000;
  MEMORY[0x20300014] |= 0x2000u;
  return result;
}
// 40006004: using guessed type int dword_40006004;
// 40006130: using guessed type int dword_40006130;

//----- (FFFF07E8) --------------------------------------------------------
unsigned int sub_FFFF07E8()
{
  unsigned int v0; // r1
  unsigned int v1; // r2
  char v2; // r6
  int v3; // r5
  unsigned int result; // r0
  int v5; // [sp+0h] [bp-18h]

  v5 = MEMORY[0x20300814] & MEMORY[0x20300BC8];
  if ( (MEMORY[0x20300814] & MEMORY[0x20300BC8]) << 31 )
  {
    MEMORY[0x20300BC8] |= 1u;
    v0 = 0;
    v1 = 256 - (MEMORY[0x20300BD0] & 0x7FFFF);
    dword_40006008 = 256 - (MEMORY[0x20300BD0] & 0x7FFFF);
    while ( v0 < v1 )
    {
      v2 = byte_40006150[v0];
      v3 = dword_40006254++;
      *((_BYTE *)&dword_40006250 + v3 + 8) = v2;
      if ( (unsigned int)dword_40006254 >= 0x400 )
        dword_40006254 = 0;
      ++v0;
    }
    MEMORY[0x20300814] |= 0x2000u;
    MEMORY[0x20300814] |= 0x10u;
    result = MEMORY[0x20300814] & 0xFFFFFFFE;
    MEMORY[0x20300814] &= 0xFFFFFFFE;
  }
  else
  {
    if ( v5 & 0x2000 )
    {
      sub_FFFF0524(6, 1, 1, 1, (int)byte_40006150);
      MEMORY[0x20300814] &= 0xFFFFDFFF;
      MEMORY[0x20300814] |= 1u;
      result = MEMORY[0x20300BC8] | 0x2000;
    }
    else
    {
      result = v5 << 19;
      if ( !(v5 & 0x1000) )
        return result;
      result = MEMORY[0x20300BC8] | 0x1000;
    }
    MEMORY[0x20300BC8] = result;
  }
  return result;
}
// 40006008: using guessed type int dword_40006008;
// 40006250: using guessed type int dword_40006250;
// 40006254: using guessed type int dword_40006254;

//----- (FFFF08C4) --------------------------------------------------------
int __fastcall sub_FFFF08C4(int a1, int a2, int a3, int a4)
{
  if ( MEMORY[0x20300B08] & 8 )
    sub_FFFF0638(MEMORY[0x20300B08] << 28, a2, a3, a4);
  if ( MEMORY[0x20300B08] << 31 )
  {
    MEMORY[0x20300B00] |= 0x8000000u;
    MEMORY[0x20300B08] |= 1u;
  }
  if ( MEMORY[0x20300B08] & 0x10 )
    MEMORY[0x20300B08] |= 0x10u;
  MEMORY[0x20300B08] = -1;
  return usb_endpoint_related(1, (int)&dword_40006130);
}
// 40006130: using guessed type int dword_40006130;

//----- (FFFF090A) --------------------------------------------------------
int __fastcall usb_EP_out_handle(int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v5; // [sp+0h] [bp-10h]

  v5 = MEMORY[0x20300818];
  MEMORY[0x20300018] &= 0xFFF7FFFF;
  if ( MEMORY[0x20300818] & 0x10000 )
    sub_FFFF08C4(MEMORY[0x20300818] << 15, a2, a3, a4);
  if ( v5 & 0x400000 )
    sub_FFFF07E8();
  result = MEMORY[0x20300018] | 0x80000;
  MEMORY[0x20300018] |= 0x80000u;
  return result;
}

//----- (FFFF093A) --------------------------------------------------------
signed int maybe_some_usb_interrupts_1()
{
  signed int result; // r0

  result = 0x20300000;
  MEMORY[0x20300018] &= 0xFFFBFFFF;             // GINTMSK unmask OEPINTMSK 
  if ( MEMORY[0x20300818] << 31 )
    MEMORY[0x20300908] = 0xFFFFFFFF;
  if ( MEMORY[0x20300818] & 0x20 )
    MEMORY[0x203009A8] = 0xFFFFFFFF;
  MEMORY[0x20300018] |= 0x40000u;               // GINTMSK mask OEPINTMSK 
  return result;
}

//----- (FFFF0970) --------------------------------------------------------
int __fastcall usb_handler(int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v5; // [sp+0h] [bp-8h]

  v5 = MEMORY[0x20300014];
  if ( MEMORY[0x20300014] & 0x40000 )
    maybe_some_usb_interrupts_1();
  if ( v5 & 0x80000 )
    usb_EP_out_handle(v5 << 12, a2, a3, a4);
  if ( v5 & 0x2000 )
    usb_enumeration_done();
  result = v5 << 19;
  if ( v5 & 0x1000 )
    result = usb_reset_handler();
  return result;
}

//----- (FFFF09A6) --------------------------------------------------------
int __fastcall sub_FFFF09A6(int a1, int a2, int a3)
{
  sub_FFFF0524(a1, 0, a3, 1, a2);
  return 0;
}

//----- (FFFF09B6) --------------------------------------------------------
int __fastcall usb_core_init(int a1)
{
  unsigned int v1; // r2
  bool v2; // zf
  int result; // r0

  v1 = 0;
  MEMORY[0x20300010] |= 1u;                     // CSFTRST reset the usb core
  do
  {
    if ( MEMORY[0x20300010] < 0 )
      break;
    ++v1;
  }
  while ( v1 < 3 );
  MEMORY[0x20300008] |= 0x20u;
  MEMORY[0x20300008] |= 0xEu;
  MEMORY[0x20300008] |= 1u;
  MEMORY[0x2030000C] &= 0xFFFFFFBF;
  MEMORY[0x2030000C] &= 0xFFFDFFFF;
  MEMORY[0x2030000C] &= 0xFFFFFFEF;
  MEMORY[0x2030000C] |= 8u;
  MEMORY[0x2030000C] &= 0xFFFFFFF8;
  MEMORY[0x2030000C] |= 0x1400u;
  MEMORY[0x20300014] = -1;
  MEMORY[0x20300800] &= 0xFFFFFFFB;
  MEMORY[0x20300800] &= 0xFFFFE7FF;
  v2 = a1 == 0;
  result = 0xC3000;
  MEMORY[0x20300018] = 0xC3000;
  if ( v2 )
  {
    result = MEMORY[0x20300800] | 1;
    MEMORY[0x20300800] |= 1u;
  }
  return result;
}

//----- (FFFF0A6C) --------------------------------------------------------
int __fastcall maybe_usb_read(_BYTE *a1)
{
  signed int v1; // r7
  _BYTE *v2; // r8
  int v3; // r9
  unsigned int v4; // r0
  int v5; // r1
  int v6; // r2
  int v7; // r3
  unsigned int v8; // r6

  v1 = 1;
  v2 = a1;
  v3 = 0;
  v4 = get_timer_tick();
  v8 = v4;
  while ( 1 )
  {
    usb_handler(v4, v5, v6, v7);
    if ( dword_40006250 != dword_40006254 )
    {
      v3 = byte_40006258[dword_40006250++];
      if ( (unsigned int)dword_40006250 >= 0x400 )
        dword_40006250 = 0;
      v1 = 0;
    }
    v4 = get_timer_tick() - v8;
    if ( v4 > 0x3E80 )
      break;
    if ( !v1 )
      return v3;
  }
  if ( v2 )
  {
    *v2 = 1;
    trace_write(4);
  }
  return v3;
}
// 40006250: using guessed type int dword_40006250;
// 40006254: using guessed type int dword_40006254;

//----- (FFFF0AF0) --------------------------------------------------------
unsigned int sub_FFFF0AF0()
{
  _DWORD *v0; // r0
  int v1; // r1
  unsigned int result; // r0
  bool v3; // cf
  int v4; // r2
  int v5; // r0
  int v6; // r0

  v0 = (_DWORD *)dword_40006014;
  while ( *(_DWORD *)(dword_40006014 + 12) & 0xFF )
    v1 = *(_DWORD *)(dword_40006014 + 4);
  if ( dword_40007EA4 == 133 )
  {
    while ( 1 )
    {
      while ( !(v0[3] & 0xFF) )
        ;
      if ( !(v0[2] & 0x80) )
        break;
      v0[5] |= 0x80u;
    }
    if ( v0[1] == 126 )
    {
      result = 144;
      dword_40007EA4 = 144;
    }
    else
    {
      result = 15000;
      do
        v3 = result-- >= 1;
      while ( v3 );
    }
  }
  else
  {
    while ( 1 )
    {
      result = dword_40007EA8;
      if ( dword_40007EA8 == 3 )
        break;
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( !(*(_DWORD *)(dword_40006014 + 12) & 0xFF) )
              ;
            v4 = *(_DWORD *)(dword_40006014 + 4);
            if ( !(*(_DWORD *)(dword_40006014 + 8) & 0x80) )
              break;
            *(_DWORD *)(dword_40006014 + 20) |= 0x80u;
          }
          if ( dword_40007EA8 )
            break;
          if ( v4 == 126 )
            dword_40007EA8 = 1;
        }
        if ( dword_40007EA8 != 1 )
          break;
        if ( v4 != 126 )
        {
          if ( v4 == 125 )
          {
            while ( !(*(_DWORD *)(dword_40006014 + 12) & 0xFF) )
              ;
            v4 = *(_DWORD *)(dword_40006014 + 4) ^ 0x20;
          }
          dword_40007EA8 = 2;
          v5 = dword_40007EBC;
          *(_BYTE *)dword_40007EBC = v4;
          dword_40007EBC = v5 + 1;
          ++dword_40007EB4;
        }
      }
      if ( dword_40007EA8 == 2 )
      {
        if ( v4 == 126 )
        {
          result = 3;
          dword_40007EA8 = 3;
          return result;
        }
        if ( v4 == 125 )
        {
          while ( !(*(_DWORD *)(dword_40006014 + 12) & 0xFF) )
            ;
          v4 = *(_DWORD *)(dword_40006014 + 4) ^ 0x20;
        }
        v6 = dword_40007EBC;
        *(_BYTE *)dword_40007EBC = v4;
        dword_40007EBC = v6 + 1;
        ++dword_40007EB4;
      }
    }
  }
  return result;
}
// 40006014: using guessed type int dword_40006014;
// 40007EA4: using guessed type int dword_40007EA4;
// 40007EA8: using guessed type int dword_40007EA8;
// 40007EB4: using guessed type int dword_40007EB4;
// 40007EBC: using guessed type int dword_40007EBC;

//----- (FFFF0BCA) --------------------------------------------------------
unsigned int __fastcall sub_FFFF0BCA(_DWORD *a1)
{
  MEMORY[0x8B000008] |= 0x300000u;
  a1[4] = 0;
  a1[9] = dword_40007EAC;
  a1[6] = 28;
  a1[7] = 0;
  a1[8] = 0;
  return sub_FFFF0AF0();
}
// 40007EAC: using guessed type int dword_40007EAC;

//----- (FFFF0BEE) --------------------------------------------------------
int sub_FFFF0BEE()
{
  int result; // r0

  dword_40007EA4 = 0x85;
  dword_40007EAC = 0xE2;
  unk_40007EB0 = 0x400;
  dword_40007EB8 = dword_4000601C;
  while ( 1 )
  {
    sub_FFFF0BCA((_DWORD *)dword_40006014);
    result = dword_40007EA4;
    if ( dword_40007EA4 == 0x90 )
      break;
    dword_40007EAC = (unsigned int)dword_40007EAC >> 1;
  }
  return result;
}
// 40006014: using guessed type int dword_40006014;
// 4000601C: using guessed type int dword_4000601C;
// 40007EA4: using guessed type int dword_40007EA4;
// 40007EAC: using guessed type int dword_40007EAC;
// 40007EB8: using guessed type int dword_40007EB8;

//----- (FFFF0C1E) --------------------------------------------------------
signed int *__fastcall sub_FFFF0C1E(unsigned __int8 *a1, int a2)
{
  int v2; // r4
  unsigned __int8 *v3; // r5
  __int16 v4; // r0
  signed int v5; // r1
  int v6; // r4
  signed int *result; // r0
  signed int v8; // t1

  v2 = a2;
  v3 = a1;
  v4 = sub_FFFF1FA0(a1, a2 - 2);
  v5 = 126;
  v3[v2 - 2] = HIBYTE(v4);
  v3[v2 - 1] = v4;
  v3[v2] = 126;
  v6 = v2 + 1;
  result = (signed int *)dword_40006014;
  while ( *(_DWORD *)(dword_40006014 + 12) & 0xFF00 )
    ;
  while ( 1 )
  {
    *result = v5;
    if ( !v6 )
      break;
    while ( result[3] & 0xFF00 )
      ;
    v8 = *v3++;
    v5 = v8;
    --v6;
  }
  while ( result[3] & 0xFF00 )
    ;
  return result;
}
// 40006014: using guessed type int dword_40006014;

//----- (FFFF0C64) --------------------------------------------------------
signed int __fastcall sub_FFFF0C64(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // r5
  _DWORD *v3; // r6

  v2 = a1;
  v3 = a2;
  dword_40007EB4 = 0;
  dword_40007EBC = dword_40007EB8;
  dword_40007EA8 = 0;
  sub_FFFF0AF0();
  if ( sub_FFFF1FA0((_BYTE *)dword_40007EB8, dword_40007EB4) )
    return 139;
  *v2 = dword_40007EB8;
  *v3 = dword_40007EB4;
  return 143;
}
// 40007EA8: using guessed type int dword_40007EA8;
// 40007EB4: using guessed type int dword_40007EB4;
// 40007EB8: using guessed type int dword_40007EB8;
// 40007EBC: using guessed type int dword_40007EBC;

//----- (FFFF0C94) --------------------------------------------------------
_DWORD *__fastcall uart_setup(_DWORD *result)
{
  result[4] = 0;
  result[9] = 226;
  result[6] = 28;
  result[7] = 0;
  result[8] = 0;
  return result;
}

//----- (FFFF0CA6) --------------------------------------------------------
int __fastcall sub_FFFF0CA6(unsigned __int8 *a1, int a2)
{
  _DWORD *v2; // r2
  int v3; // t1
  int result; // r0

  v2 = (_DWORD *)dword_40006014;
  while ( a2 )
  {
    while ( v2[3] & 0xFF00 )
      ;
    v3 = *a1++;
    --a2;
    *v2 = v3;
  }
  do
    result = v2[3];
  while ( result & 0xFF00 );
  return result;
}
// 40006014: using guessed type int dword_40006014;

//----- (FFFF0CD8) --------------------------------------------------------
BOOL sub_FFFF0CD8()
{
  int v0; // r0
  int v1; // r4
  int v2; // r1
  int v3; // r6

  v0 = get_timer_tick();
  v1 = v0;
  v2 = mmc_selected;
  *(_DWORD *)(mmc_selected + 44) |= 0x1000000u;
  v3 = *(_DWORD *)(v2 + 44);
  while ( v3 & 0x1000000 && (unsigned int)(v0 - v1) < 0x64 )
  {
    v3 = *(_DWORD *)(mmc_selected + 44);
    v0 = get_timer_tick();
  }
  return (unsigned int)(v0 - v1) <= 0x64;
}
// 4000600C: using guessed type int mmc_selected;

//----- (FFFF0D34) --------------------------------------------------------
unsigned int __fastcall sub_FFFF0D34(int a1)
{
  int v1; // r6
  unsigned int result; // r0
  unsigned int v3; // r5
  int v4; // r1
  int v5; // r6

  v1 = a1;
  result = get_timer_tick();
  v3 = result;
  if ( v1 == 1 )
  {
    v4 = mmc_selected;
    *(_DWORD *)(mmc_selected + 44) |= 1u;
    v5 = *(_DWORD *)(v4 + 44);
    while ( !(v5 & 2) )
    {
      result -= v3;
      if ( result >= 0x64 )
        break;
      v5 = *(_DWORD *)(mmc_selected + 44);
      result = get_timer_tick();
    }
  }
  else
  {
    result = mmc_selected;
    *(_DWORD *)(mmc_selected + 44) &= 0xFFFFFFFE;
  }
  return result;
}
// 4000600C: using guessed type int mmc_selected;

//----- (FFFF0DA0) --------------------------------------------------------
int __fastcall sub_FFFF0DA0(int a1)
{
  int v1; // r6
  int v2; // r7
  int v3; // r5
  int result; // r0
  int v5; // r7

  v2 = a1;
  v3 = get_timer_tick();
  if ( v2 == 1 )
  {
    sub_FFFF0D34(1);
    result = mmc_selected;
    *(_DWORD *)(mmc_selected + 44) |= 4u;
    v5 = *(_DWORD *)(result + 44);
    while ( !(v5 & 2) )
    {
      result = v1 - v3;
      if ( (unsigned int)(v1 - v3) >= 0x64 )
        break;
      v5 = *(_DWORD *)(mmc_selected + 44);
      result = get_timer_tick();
      v1 = result;
    }
  }
  else
  {
    result = mmc_selected;
    *(_DWORD *)(mmc_selected + 44) &= 0xFFFFFFFB;
  }
  return result;
}
// 4000600C: using guessed type int mmc_selected;

//----- (FFFF0E18) --------------------------------------------------------
int sub_FFFF0E18()
{
  int v0; // r0

  v0 = mmc_selected;
  *(_DWORD *)(mmc_selected + 40) &= 0xFFFFFFFD;
  *(_DWORD *)(v0 + 40) &= 0xFFFFFFFB;
  *(_DWORD *)(v0 + 44) = *(_DWORD *)(v0 + 44) & 0xFFFF00FF | 0x800;
  sub_FFFF0D34(1);
  return sub_FFFF0DA0(1);
}
// 4000600C: using guessed type int mmc_selected;

//----- (FFFF0E60) --------------------------------------------------------
BOOL __fastcall select_mmc(int a1)
{
  bool v1; // zf
  unsigned int v2; // r0

  v1 = a1 == 0;
  v2 = 0;
  mmc_selected = 0x20500000;                    // Select MMC0
  if ( v1 )                                     // v1 == 0, i.e. if(0), T_T
  {
    MEMORY[0x20900200] |= 0x10u;
    MEMORY[0x20900210] |= 0x1000u;
    do
      ++v2;
    while ( v2 < 0xFF );
    MEMORY[0x20900210] &= 0xFFFFEFFF;
    MEMORY[0x20900228] &= 0xFFFFFFFC;
    MEMORY[0x8C0000A4] &= 0xFFFFFCFF;
    MEMORY[0x8C0000A4] |= 0x200u;
    mmc_selected = 0x20500000;
  }
  else                                          // Hardcoded to select MMC1
  {
    MEMORY[0x20900200] |= 0x80000u;
    MEMORY[0x20900210] |= 0x10000u;
    do
      ++v2;
    while ( v2 < 0xFF );
    MEMORY[0x20900210] &= 0xFFFEFFFF;
    MEMORY[0x20900228] &= 0xFFFFFFF3;
    MEMORY[0x8C0003E8] &= 0xFFFFFCFF;
    MEMORY[0x8C0003E8] |= 0x200u;
    mmc_selected = 0x20600000;
  }
  return sub_FFFF0CD8();
}
// 4000600C: using guessed type int mmc_selected;

//----- (FFFF0F44) --------------------------------------------------------
unsigned int __fastcall sub_FFFF0F44(int a1)
{
  int v1; // r1
  int v2; // r2
  unsigned int result; // r0

  v1 = mmc_selected;
  v2 = *(_DWORD *)(mmc_selected + 52);
  *(_DWORD *)(mmc_selected + 52) &= 0xFFEFFFFF;
  result = *(_DWORD *)(v1 + 44) & 0xFFF0FFFF | (a1 << 16);
  *(_DWORD *)(v1 + 44) = result;
  *(_DWORD *)(v1 + 52) = v2;
  return result;
}
// 4000600C: using guessed type int mmc_selected;

//----- (FFFF0F74) --------------------------------------------------------
signed int __fastcall sub_FFFF0F74(int a1, int a2)
{
  int v2; // r6
  int v3; // r5
  int v4; // r1
  _DWORD *v5; // r2
  int v6; // r0
  int v7; // r0
  int v8; // r5
  int v9; // r0

  v2 = a2;
  v3 = a1;
  v4 = mmc_selected;
  *(_DWORD *)(mmc_selected + 56) = 0;
  *(_DWORD *)(v4 + 52) = 0;
  sub_FFFF0F44(14);
  v5 = (_DWORD *)mmc_selected;
  *(_DWORD *)(mmc_selected + 48) = 7372811;
  v5[13] = 7340043;
  v5[14] = 7340043;
  *v5 = v2;
  v6 = mmc_selected;
  *(_DWORD *)(mmc_selected + 4) = (v3 << 16) | 0x7200;
  *(_DWORD *)(v6 + 8) = -6;
  *(_DWORD *)(v6 + 12) = 2097203;
  v7 = get_timer_tick();
  v8 = v7;
  while ( (unsigned int)(v7 - v8) < 0x7D0 )
  {
    v9 = *(_DWORD *)(mmc_selected + 48);
    if ( v9 & 0x708000 )
      break;
    if ( !(~v9 & 3) )
      return 1;
    v7 = get_timer_tick();
  }
  return 0;
}
// 4000600C: using guessed type int mmc_selected;

//----- (FFFF1020) --------------------------------------------------------
signed int sub_FFFF1020()
{
  int v0; // r0
  _DWORD *v1; // r0
  int v2; // r0
  int v3; // r4
  int v4; // r0

  v0 = mmc_selected;
  *(_DWORD *)(mmc_selected + 56) = 0;
  *(_DWORD *)(v0 + 52) = 0;
  sub_FFFF0F44(14);
  v1 = (_DWORD *)mmc_selected;
  *(_DWORD *)(mmc_selected + 48) = 1;
  v1[13] = 1;
  v1[14] = 1;
  v1[2] = -252645136;
  v1[3] = 0;
  v2 = get_timer_tick();
  v3 = v2;
  while ( (unsigned int)(v2 - v3) < 0x64 )
  {
    v4 = *(_DWORD *)(mmc_selected + 48);
    if ( v4 & 0x8000 )
      break;
    if ( !(~v4 & 1) )
      return 1;
    v2 = get_timer_tick();
  }
  return 0;
}
// 4000600C: using guessed type int mmc_selected;

//----- (FFFF10C4) --------------------------------------------------------
BOOL sub_FFFF10C4()
{
  return dword_40000020 == -1437227611 && dword_40000024 == sub_FFFF1692((unsigned __int16 *)&unk_40000028, 24536);
}
// 40000020: using guessed type int dword_40000020;
// 40000024: using guessed type int dword_40000024;

//----- (FFFF1100) --------------------------------------------------------
signed int read_spl_from_emmc()
{
  int v0; // r6
  int v1; // r5
  int v2; // r4
  int v3; // r0

  sub_FFFF1610();
  v0 = read_unknown_ctrl5_4();
  v1 = read_unknown_ctrl5_2();
  v2 = 0;
  while ( 1 )
  {
    sub_FFFF163A(1);
    sub_FFFF1556(v0, 1, v1);
    select_mmc(v0);
    sub_FFFF0E18();
    trace_write(0x80000);
    sleep();
    if ( sub_FFFF1020() == 1 )
      break;
    v3 = 0x100000;
LABEL_5:
    trace_write(v3);
    sub_FFFF1556(v0, 0, v1);
    sub_FFFF163A(0);
    sleep();
    if ( (unsigned int)++v2 >= 2 )
      return 0;
  }
  sleep();
  if ( sub_FFFF0F74(48, 0x40000000) != 1 )
  {
    v3 = 0x200000;
    goto LABEL_5;
  }
  if ( sub_FFFF10C4() != 1 )
  {
    v3 = 0x400000;
    goto LABEL_5;
  }
  trace_write(0x800000);
  return 1;
}

//----- (FFFF11DC) --------------------------------------------------------
signed int maybe_clock_init()
{
  signed int result; // r0

  result = 0x8B000000;
  MEMORY[0x8B00000C] |= 2u;                     // Set GR_PCTL
  return result;
}

//----- (FFFF11EA) --------------------------------------------------------
signed int sub_FFFF11EA()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r0
  signed int result; // r0

  v0 = (_DWORD *)0x8C0000E0;
  MEMORY[0x8B000008] |= 0x2000u;                // GR_GEN0 bit[14] unknown
  MEMORY[0x8B000008] |= 0x4000100u;             // GR_GEN0 bit[9] enable APB clock Enable of EIC module 
                                                // GR_GEN0 bit[27] unknown
  do
  {
    *v0 |= 0x80u;
    ++v0;
  }
  while ( (unsigned int)v0 <= 0x8C0000FC );
  v1 = (_DWORD *)0x8C00019C;
  do
  {
    *v1 &= 0xFFFFFEFF;
    *v1 |= 0x200u;
    ++v1;
  }
  while ( (unsigned int)v1 <= 0x8C0002A8 );
  result = 0x8C000000;
  MEMORY[0x8C000000] |= 0x3000u;                // Chip pin registers 
  return result;
}

//----- (FFFF1238) --------------------------------------------------------
signed int sub_FFFF1238()
{
  signed int result; // r0

  result = 0x8B000000;
  MEMORY[0x8B000008] |= 0x8080000u;
  return result;
}

//----- (FFFF1246) --------------------------------------------------------
_DWORD *uart_init()
{
  MEMORY[0x8B00000C] &= 0xFFFFFEFF;
  MEMORY[0x8B00005C] |= 0xF00000u;
  MEMORY[0x8B000008] |= 0x300000u;
  uart_setup((_DWORD *)0x83000000);
  return uart_setup((_DWORD *)0x84000000);
}

//----- (FFFF1278) --------------------------------------------------------
int keypad_init()
{
  signed int v0; // r1
  int result; // r0

  v0 = 0;
  MEMORY[0x8B000008] |= 0x4000100u;
  MEMORY[0x8B00004C] |= 2u;
  do
    ++v0;
  while ( v0 < 10 );
  MEMORY[0x8B00004C] &= 0xFFFFFFFD;
  MEMORY[0x87000010] = 0xFFF;
  MEMORY[0x87000018] = 0xFFFF;
  MEMORY[0x87000028] = 0;
  MEMORY[0x8700001C] = 0xF;                     // KPD_DEBOUNCE_CNT Counter for de-bounce time 
  result = MEMORY[0x87000000] | 1;
  MEMORY[0x87000000] |= 1u;                     // KPD_EN enable keypad
  return result;
}

//----- (FFFF12C0) --------------------------------------------------------
int sub_FFFF12C0()
{
  unsigned int v0; // r1
  bool v1; // cf
  int result; // r0

  MEMORY[0x8B000008] |= 0x40u;
  MEMORY[0x8B00004C] |= 0x400000u;
  v0 = 50;
  do
    v1 = v0-- >= 1;
  while ( v1 );
  MEMORY[0x8B00004C] &= 0xFFBFFFFF;
  MEMORY[0x82000004] &= 0xFFFFFFFD;
  result = MEMORY[0x82000008];
  MEMORY[0x82000008] = 0;
  return result;
}

//----- (FFFF12F6) --------------------------------------------------------
signed int disable_keypad()
{
  signed int result; // r0

  result = 0x8B000000;
  MEMORY[0x87000010] = 0xFFF;                   // Keypad interrupt clear
  MEMORY[0x8B000008] &= 0xFBFFFEFF;             // disable keypad clocks
  return result;
}

//----- (FFFF1310) --------------------------------------------------------
int get_timer_tick()
{
  int result; // r0

  do
    result = MEMORY[0x87003004];
  while ( MEMORY[0x87003004] != MEMORY[0x87003004] );
  return result;
}

//----- (FFFF131C) --------------------------------------------------------
signed int __fastcall sub_FFFF131C(_DWORD *a1, int a2)
{
  _DWORD *v2; // r4
  int v3; // r5
  int v4; // r0
  int v5; // r3

  v2 = a1;
  v3 = a2;
  get_timer_tick();
  while ( !(MEMORY[0x8200002C] & 0x400) )
  {
    v4 = get_timer_tick();
    if ( (unsigned int)(v4 - v5) >= 0xA )
      return -1;
  }
  *v2 = v3;
  return 0;
}

//----- (FFFF1348) --------------------------------------------------------
signed int __fastcall sub_FFFF1348(int a1)
{
  int v1; // r4
  int v2; // r3

  MEMORY[0x82000024] = a1;
  v1 = get_timer_tick();
  do
  {
    if ( (unsigned int)(get_timer_tick() - v1) >= 0xA )
      return -1;
  }
  while ( v2 < 0 );
  return (unsigned __int16)v2;
}

//----- (FFFF1370) --------------------------------------------------------
int sub_FFFF1370()
{
  int result; // r0

  result = sub_FFFF1348(0x82000600);
  if ( result != -1 )
  {
    sub_FFFF131C((_DWORD *)0x82000600, (unsigned __int16)result | 0x202);
    result = 0;
  }
  return result;
}

//----- (FFFF1390) --------------------------------------------------------
int __fastcall trace_write(int result)
{
  g_TraceValue |= result;
  return result;
}
// 40006000: using guessed type int g_TraceValue;

//----- (FFFF139A) --------------------------------------------------------
int platform_init()
{
  maybe_clock_init();
  sub_FFFF11EA();
  sub_FFFF1238();
  uart_init();
  sub_FFFF12C0();
  sub_FFFF1370();
  keypad_init();
  return trace_write(0x20000);
}

//----- (FFFF13C2) --------------------------------------------------------
unsigned int sleep()
{
  unsigned int result; // r0
  unsigned int v1; // r3

  get_timer_tick();
  do
    result = get_timer_tick();
  while ( result < v1 );
  return result;
}

//----- (FFFF13D6) --------------------------------------------------------
BOOL read_unknown_ctrl5_1()
{
  return (unsigned __int8)(MEMORY[0x20900218] & 0x80) != 0;// 'CTRL5, Remap control' in doc page 512
                                                // But it's not actually just about remap!
                                                // Only bit 1 is remap control. The other bits are undocumented.
                                                // It seems that spreadtrum left that out on purpose.
                                                // This can be proved by strange comments in their code as well as some mistakes found in their doc
}

//----- (FFFF13E6) --------------------------------------------------------
BOOL maybe_if_allow_uart_download()
{
  return (MEMORY[0x20900218] & 4) == 0;
}

//----- (FFFF13F6) --------------------------------------------------------
signed int sub_FFFF13F6()
{
  signed int result; // r0

  result = MEMORY[0x8B00001C] << 31;
  if ( MEMORY[0x8B00001C] << 31 )
    result = 1;
  return result;
}

//----- (FFFF1404) --------------------------------------------------------
int CheckSecureBootEnable()
{
  int result; // r0
  int v1; // r4

  result = sub_FFFF13F6();
  if ( result )
  {
    efuse_parameter_config_1();
    v1 = sub_FFFF33FA((int)efuse_hash_data);
    efuse_parameter_config_2();
    if ( v1 )
    {
      trace_write(0x40000);
    }
    else if ( efuse_hash_data[0] >= 0 )
    {
      return 0;
    }
    result = 1;
  }
  return result;
}
// 40006658: using guessed type int efuse_hash_data[];

//----- (FFFF143A) --------------------------------------------------------
signed int __fastcall maybe_USB_LDO_Control(int a1)
{
  int v1; // r4
  signed int result; // r0
  int v3; // r1

  v1 = a1;
  result = sub_FFFF1348(0x82000610);
  if ( result != -1 )
  {
    result = (unsigned __int16)result;
    if ( v1 )
      v3 = result & 0xFFFFFFFE | 2;
    else
      v3 = result & 0xFFFFFFFD | 1;
    result = sub_FFFF131C((_DWORD *)0x82000610, v3);
  }
  return result;
}

//----- (FFFF146C) --------------------------------------------------------
signed int sub_FFFF146C()
{
  signed int result; // r0

  result = 0x2090020C;
  MEMORY[0x2090020C] &= 0xFFFFFFFE;
  MEMORY[0x2090020C] |= 0x40u;
  return result;
}

//----- (FFFF1480) --------------------------------------------------------
signed int __fastcall HashVerify(int a1, int a2)
{
  int *v2; // r4
  int v3; // r5
  unsigned int v4; // r0
  signed int result; // r0

  v2 = (int *)a1;
  v3 = a2;
  MD5Init(soft_hash_data);
  MD5Final(v2, v3, (int)soft_hash_data);
  v4 = 0;
  do
  {
    soft_hash_data[v4] &= 0x7FFFFFFFu;
    efuse_hash_data[v4] &= 0x7FFFFFFFu;
    ++v4;
  }
  while ( v4 < 4 );
  if ( soft_hash_data[0] != efuse_hash_data[0]
    || dword_4000666C != dword_4000665C
    || dword_40006670 != dword_40006660
    || dword_40006674 != dword_40006664 )
  {
    trace_write(0x10000);
    result = 0;
  }
  else
  {
    trace_write(0x8000);
    result = 1;
  }
  return result;
}
// 40006658: using guessed type int efuse_hash_data[];
// 4000665C: using guessed type int dword_4000665C;
// 40006660: using guessed type int dword_40006660;
// 40006664: using guessed type int dword_40006664;
// 40006668: using guessed type int soft_hash_data[];
// 4000666C: using guessed type int dword_4000666C;
// 40006670: using guessed type int dword_40006670;
// 40006674: using guessed type int dword_40006674;

//----- (FFFF14F8) --------------------------------------------------------
int maybe_check_usb_download()
{
  int result; // r0

  result = MEMORY[0x20900218] & 2;
  if ( MEMORY[0x20900218] & 2 )
    result = 1;
  return result;
}

//----- (FFFF1506) --------------------------------------------------------
BOOL read_unknown_ctrl5_3()
{
  return (MEMORY[0x20900218] & 8) == 0;
}

//----- (FFFF1516) --------------------------------------------------------
int __fastcall sub_FFFF1516(int a1)
{
  g_TraceValue |= a1;
  return sub_FFFF0CA6((unsigned __int8 *)&g_TraceValue, 4);
}
// 40006000: using guessed type int g_TraceValue;

//----- (FFFF1526) --------------------------------------------------------
BOOL is_booting_from_emmc()
{
  return (MEMORY[0x20900218] & 0x10) == 0;
}

//----- (FFFF1536) --------------------------------------------------------
BOOL read_unknown_ctrl5_4()
{
  return (MEMORY[0x20900218] & 0x40) != 0;
}

//----- (FFFF1546) --------------------------------------------------------
BOOL read_unknown_ctrl5_2()
{
  return (MEMORY[0x20900218] & 0x20) == 0;
}

//----- (FFFF1556) --------------------------------------------------------
int __fastcall sub_FFFF1556(int a1, int a2, int a3)
{
  int v3; // r4
  int v4; // r5
  unsigned int v5; // r0
  unsigned __int16 v6; // r0
  _DWORD *v7; // r5
  unsigned int v8; // r0
  unsigned __int16 v9; // r0
  unsigned int v11; // r0
  unsigned __int16 v12; // r0
  unsigned int v13; // r0

  v3 = a2;
  v4 = a3;
  if ( a1 )
  {
    v5 = sub_FFFF1348(0x82000624) & 0xFFFF0FFF;
    if ( v4 )
      v6 = v5 | 0x9000;
    else
      v6 = v5 | 0x5000;
    sub_FFFF131C((_DWORD *)0x82000624, v6);
    v7 = (_DWORD *)0x82000614;
    v8 = sub_FFFF1348(0x82000614) & 0xFFFFFFFC;
    if ( v3 == 1 )
      v9 = v8 | 2;
    else
      v9 = v8 | 1;
  }
  else
  {
    v11 = sub_FFFF1348(0x8200061C) & 0xFFFF0FFF;
    if ( v4 )
      v12 = v11 | 0x9000;
    else
      v12 = v11 | 0x5000;
    sub_FFFF131C((_DWORD *)0x8200061C, v12);
    v7 = (_DWORD *)0x82000610;
    v13 = sub_FFFF1348(0x82000610) & 0xFFFFFFF3;
    if ( v3 == 1 )
      v9 = v13 | 8;
    else
      v9 = v13 | 4;
  }
  return sub_FFFF131C(v7, v9);
}

//----- (FFFF1610) --------------------------------------------------------
signed int sub_FFFF1610()
{
  unsigned int v0; // r0
  unsigned int v1; // r2
  signed int result; // r0

  v0 = 0;
  do
  {
    v1 = v0++;
    *(_DWORD *)(4 * v1 - 0x73FFFE84) |= 0x30u;
  }
  while ( v0 < 8 );
  result = 0x8C000408;
  MEMORY[0x8C000408] |= 0x30u;                  // NFCEN1 
  return result;
}

//----- (FFFF163A) --------------------------------------------------------
int __fastcall sub_FFFF163A(int a1)
{
  int v1; // r4
  __int16 v2; // r0
  unsigned int v3; // r0
  unsigned __int16 v4; // r0

  v1 = a1;
  v2 = sub_FFFF1348(0x82000628);
  sub_FFFF131C((_DWORD *)0x82000628, (unsigned __int16)(v2 & 0xF0FF) | 0x900);
  v3 = sub_FFFF1348(0x82000614) & 0xFFFFFF3F;
  if ( v1 == 1 )
    v4 = v3 | 0x80;
  else
    v4 = v3 | 0x40;
  return sub_FFFF131C((_DWORD *)0x82000614, v4);
}

//----- (FFFF1688) --------------------------------------------------------
int __fastcall sub_FFFF1688(int result, unsigned __int8 a2, unsigned int a3)
{
  unsigned __int8 v3; // r3
  unsigned int v4; // r1
  int v5; // r2
  int v6; // r12
  _BYTE *v7; // r0

  v3 = a2;
  v4 = a3;
  v5 = v3 | (v3 << 8) | ((v3 | (v3 << 8)) << 16);
  if ( v4 < 4 )
  {
    if ( __CFSHL__(v4, 31) )
    {
      *(_BYTE *)result = v5;
      v7 = (_BYTE *)(result + 1);
      *v7 = v5;
      result = (int)(v7 + 1);
    }
    if ( ((v4 << 31) & 0x80000000) != 0 )
      *(_BYTE *)result++ = v5;
  }
  else if ( result & 3 )
  {
    v6 = 4 - (result & 3);
    if ( v6 != 2 )
      *(_BYTE *)result++ = v5;
    if ( v6 >= 2 )
    {
      *(_WORD *)result = v3 | (unsigned __int16)(v3 << 8) | ((v3 | (unsigned __int16)(v3 << 8)) << 16);
      result += 2;
    }
    result = (int)sub_FFFF22E0((_DWORD *)result, v4 - v6, v3 | (v3 << 8) | ((v3 | (v3 << 8)) << 16));
  }
  else
  {
    result = (int)sub_FFFF22E0((_DWORD *)result, v4, v3 | (v3 << 8) | ((v3 | (v3 << 8)) << 16));
  }
  return result;
}

//----- (FFFF1692) --------------------------------------------------------
int __fastcall sub_FFFF1692(unsigned __int16 *a1, signed int a2)
{
  unsigned int v2; // r2
  int v3; // r3
  int v4; // t1

  v2 = 0;
  while ( a2 > 3 )
  {
    v3 = *(_DWORD *)a1;
    a1 += 2;
    a2 -= 4;
    v2 += v3;
  }
  if ( a2 & 2 )
  {
    v4 = *a1;
    ++a1;
    v2 += v4;
  }
  if ( a2 << 31 )
    v2 += *(unsigned __int8 *)a1;
  return (unsigned __int16)~((v2 >> 16) + v2 + (((v2 >> 16) + (unsigned __int16)v2) >> 16));
}

//----- (FFFF16C4) --------------------------------------------------------
signed int nand_stuffs_1()
{
  unsigned int v0; // r0
  unsigned int v1; // r2
  unsigned int v2; // r1
  _DWORD *v3; // r1
  signed int result; // r0

  v0 = 0;
  MEMORY[0x20900200] |= 0x100u;
  MEMORY[0x20900210] |= 0x20u;
  do
    ++v0;
  while ( v0 < 0x64 );
  v1 = 0;
  MEMORY[0x20900210] &= 0xFFFFFFDF;
  MEMORY[0x8C000140] &= 0xFFFFFEFF;             // pin multiplex
  MEMORY[0x8C000140] |= 0x200u;
  MEMORY[0x8C000144] |= 0x280u;
  MEMORY[0x8C000144] &= 0xFFFFFEFF;
  do
  {
    v2 = v1++;
    v3 = (_DWORD *)(4 * v2 - 1946156728);
    *v3 |= 0x200u;
    *v3 &= 0xFFFFFEFF;
  }
  while ( v1 < 0x15 );
  result = 0xFFFF3CFF;
  MEMORY[0x60000010] = 0xFFFF3CFF;
  return result;
}

//----- (FFFF1742) --------------------------------------------------------
// Disable NAND after failed to boot
signed int disable_nfc()
{
  signed int v0; // r1
  signed int result; // r0

  v0 = 0;
  MEMORY[0x20900210] |= 0x20u;                  // Set or reset bit[5] of 0x2090_0210 to reset NFC module 
  do
    ++v0;
  while ( v0 < 100 );
  result = 0x20900200;
  MEMORY[0x20900210] &= 0xFFFFFFDF;             // 0x2090_0210 bit[5] = 0
  MEMORY[0x20900200] &= 0xFFFFFEFF;             // 0x2090_0200 bit[8] = 0 disable NFC clock
  return result;
}

//----- (FFFF176E) --------------------------------------------------------
signed int sub_FFFF176E()
{
  int v0; // r5
  int v1; // r6
  int v2; // r0
  int v3; // r5
  signed int result; // r0

  MEMORY[0x60000060] = 0x1FA01FA;
  MEMORY[0x60000004] |= 0x8000u;
  MEMORY[0x60000000] = 0x8000FFFD;
  v0 = get_timer_tick();
  while ( (unsigned int)(get_timer_tick() - v0) < 2 )
    ;
  v1 = MEMORY[0x60000004];
  get_timer_tick();
  v2 = get_timer_tick();
  v3 = v2;
  while ( !(v1 << 31) && (unsigned int)(v2 - v3) < 5 )
  {
    v1 = MEMORY[0x60000004];
    v2 = get_timer_tick();
  }
  MEMORY[0x60000004] &= 0xFFFF7FFF;
  if ( (unsigned int)(v2 - v3) >= 5 )
    result = 2;
  else
    result = 0;
  return result;
}

//----- (FFFF17C8) --------------------------------------------------------
signed int __fastcall sub_FFFF17C8(int a1)
{
  signed int result; // r0

  if ( ((*(_DWORD *)((a1 & 0xFFFFFFFC) + 1610612800) >> (8 * a1 & 0x1F)) & 0x1F) == 31 )
    result = 5;
  else
    result = 0;
  return result;
}

//----- (FFFF17EA) --------------------------------------------------------
signed int __fastcall sub_FFFF17EA(unsigned __int8 *a1)
{
  int v1; // r1

  v1 = *a1 * *((unsigned __int16 *)a1 + 5);
  switch ( v1 )
  {
    case 512:
      return 3;
    case 2048:
      return 8;
    case 4096:
      return 16;
  }
  return 32;
}

//----- (FFFF1812) --------------------------------------------------------
signed int __fastcall sub_FFFF1812(unsigned __int8 *a1, int a2)
{
  int v2; // r6
  unsigned __int8 *v3; // r4
  unsigned int v4; // r5
  char v5; // r7
  int v6; // r0
  int v7; // r6
  signed int result; // r0
  unsigned int i; // r5

  v2 = a2;
  v3 = a1;
  v4 = sub_FFFF17EA(a1);
  if ( v3[3] && !v3[4] )
    MEMORY[0x60000060] = 2 * v2;
  else
    MEMORY[0x60000060] = v2;
  MEMORY[0x60000080] = -1;
  MEMORY[0x60000024] = 2031616;
  MEMORY[0x60000004] = ((v3[2] << 12) - 12288) | ((*v3 * v3[6] - 1) << 16) | (v3[1] << 14) | (v3[3] << 9) | 32 * v3[4];
  MEMORY[0x60000030] = (((signed int)reset >> 8) + (v3[7] << 8)) | ((unsigned int)reset + 0x10000 * v3[6]) | (v3[5] << 24) | 16 * v3[8] | 6;
  MEMORY[0x60000034] = *((unsigned __int16 *)v3 + 5) - 1;
  MEMORY[0x60000000] = (signed int)reset >> 8 << 23;
  v5 = 0;
  v6 = get_timer_tick();
  v7 = v6;
  while ( !(v5 & 2) && v6 - v7 < v4 )
  {
    v5 = MEMORY[0x60000024];
    v6 = get_timer_tick();
  }
  MEMORY[0x60000030] &= 0xFFFFFFFD;
  if ( v6 - v7 >= v4 )
    return 2;
  for ( i = 0; *v3 > i; ++i )
  {
    result = sub_FFFF17C8(i);
    if ( result == 5 )
      return result;
  }
  return 0;
}

//----- (FFFF18EC) --------------------------------------------------------
signed int __fastcall sub_FFFF18EC(unsigned __int16 *a1)
{
  char v1; // r6
  int v2; // r0
  int v3; // r5
  unsigned int v4; // r0

  MEMORY[0x60000024] = 2031616;
  MEMORY[0x60000034] = *((_DWORD *)a1 + 1) - 1;
  MEMORY[0x60000030] = ((unsigned int)reset + 0x10000 * *a1) | (a1[1] << 24) | 0x65;
  v1 = 0;
  v2 = get_timer_tick();
  v3 = v2;
  while ( 1 )
  {
    v4 = v2 - v3;
    if ( v1 & 2 )
      break;
    if ( v4 >= 0x10 )
      return 2;
    v1 = MEMORY[0x60000024];
    v2 = get_timer_tick();
  }
  if ( v4 >= 0x10 )
    return 2;
  return sub_FFFF17C8(0);
}

//----- (FFFF1940) --------------------------------------------------------
signed int __fastcall sub_FFFF1940(unsigned __int8 *a1, int a2)
{
  signed int v2; // r6
  int v3; // r0
  int v4; // r5
  unsigned int v5; // r0

  if ( a1[3] && !a1[4] )
  {
    MEMORY[0x60000060] = 2 * a2;
    MEMORY[0x60000080] = 2 * a2 + 511;
  }
  else
  {
    MEMORY[0x60000060] = a2;
    MEMORY[0x60000080] = a2 + 511;
  }
  MEMORY[0x60000024] = 2031616;
  MEMORY[0x60000004] = (a1[1] << 14) | (a1[2] << 12) | (a1[3] << 9) | 32 * a1[4];
  MEMORY[0x60000000] = 2147483648;
  v2 = 2031616;
  v3 = get_timer_tick();
  v4 = v3;
  while ( 1 )
  {
    v5 = v3 - v4;
    if ( v2 << 31 )
      break;
    if ( v5 >= 0x10 )
      return 2;
    v2 = MEMORY[0x60000024];
    v3 = get_timer_tick();
  }
  if ( v5 >= 0x10 )
    return 2;
  return 0;
}

//----- (FFFF19D4) --------------------------------------------------------
signed int *__fastcall sub_FFFF19D4(unsigned int a1)
{
  __int16 v1; // r1
  int v2; // r0

  v1 = sub_FFFF23BC(a1);
  v2 = dword_40006018;
  *(_WORD *)dword_40006018 = v1;
  *(_WORD *)(v2 + 2) = 0;
  return sub_FFFF0C1E((unsigned __int8 *)v2, 6);
}
// 40006018: using guessed type int dword_40006018;

//----- (FFFF19F0) --------------------------------------------------------
void __fastcall __noreturn sub_FFFF19F0(int a1, int a2, unsigned __int16 *a3, int a4)
{
  signed int v4; // r0
  unsigned int v5; // r0
  unsigned __int16 *v6; // [sp+0h] [bp-10h]
  int v7; // [sp+4h] [bp-Ch]

  v6 = a3;
  v7 = a4;
  while ( 1 )
  {
    v4 = sub_FFFF0C64(&v6, &v7);
    if ( v4 == 143 )
    {
      v5 = sub_FFFF23BC(*v6);
      off_FFFF2440[v5](v6, v7);
    }
    else
    {
      sub_FFFF19D4(v4);
      sub_FFFF1688((int)&word_40007E8C, 0, 0x18u);
    }
  }
}
// 40007E8C: using guessed type __int16 word_40007E8C;

//----- (FFFF1A7C) --------------------------------------------------------
int __fastcall detect_uart_download(int a1, int *a2, _BYTE *a3)
{
  int result; // r0

  if ( *(_DWORD *)(a1 + 0xC) & 0xFF )
  {
    if ( *(_DWORD *)(a1 + 4) == 0x7E )          // 0x7E received
      result = *a2 + 1;
    else
      result = 0;
    *a2 = result;
  }
  else
  {
    result = 1;
    *a3 = 1;
  }
  return result;
}

//----- (FFFF1A9C) --------------------------------------------------------
unsigned int __fastcall check_uart_download(int a1)
{
  unsigned int result; // r0
  char v3; // [sp+4h] [bp-3Ch]
  char v4; // [sp+8h] [bp-38h]
  int v5; // [sp+Ch] [bp-34h]
  unsigned int v6; // [sp+10h] [bp-30h]
  unsigned int v7; // [sp+14h] [bp-2Ch]

  v3 = 0;
  v4 = 0;
  v6 = 0;
  v7 = 0;
  v5 = get_timer_tick();
  do
  {
    detect_uart_download(0x84000000, (int *)&v7, &v4);
    detect_uart_download(0x83000000, (int *)&v6, &v3);
    if ( v7 >= 3 )
    {
LABEL_3:
      *(_BYTE *)(a1 + 1) = 1;
      result = 0x6A00;
      dword_40006014 = 0x84000000;
LABEL_6:
      MEMORY[0x8B000020] = result;
      return result;
    }
    if ( v6 >= 3 )
    {
      *(_BYTE *)(a1 + 1) = 1;
      result = 0x7A00;
      dword_40006014 = 0x83000000;
      goto LABEL_6;
    }
  }
  while ( (!v4 || !v3) && (unsigned int)(get_timer_tick() - v5) <= 0x78 );
  while ( 1 )
  {
    result = get_timer_tick() - dword_40006010;
    if ( result > 0x78 )
      return result;
    detect_uart_download(0x84000000, (int *)&v7, &v4);
    detect_uart_download(0x83000000, (int *)&v6, &v3);
    if ( v7 >= 3 )
      goto LABEL_3;
    result = v6;
    if ( v6 >= 3 )
    {
      *(_BYTE *)(a1 + 1) = 1;
      dword_40006014 = 0x83000000;
      MEMORY[0x8B000020] = 0x7A00;
      return result;
    }
  }
}
// 40006010: using guessed type int dword_40006010;
// 40006014: using guessed type int dword_40006014;

//----- (FFFF1B5C) --------------------------------------------------------
signed int __fastcall sub_FFFF1B5C(int a1)
{
  *(_BYTE *)a1 = MEMORY[0x60002048];
  *(_BYTE *)(a1 + 1) = MEMORY[0x60002030];
  *(_BYTE *)(a1 + 2) = MEMORY[0x60002028];
  *(_BYTE *)(a1 + 3) = MEMORY[0x60002024];
  *(_BYTE *)(a1 + 4) = MEMORY[0x6000202C];
  *(_BYTE *)(a1 + 5) = MEMORY[0x60002040];
  *(_BYTE *)(a1 + 6) = MEMORY[0x60002038];
  *(_BYTE *)(a1 + 7) = MEMORY[0x60002048];
  *(_BYTE *)(a1 + 8) = MEMORY[0x6000203C];
  *(_WORD *)(a1 + 10) = MEMORY[0x60002044];
  return 1;
}

//----- (FFFF1B8C) --------------------------------------------------------
signed int __fastcall sub_FFFF1B8C(int a1, int a2, int a3, unsigned int a4)
{
  int v5; // [sp+0h] [bp-10h]
  unsigned int v6; // [sp+4h] [bp-Ch]

  v5 = a3;
  v6 = a4;
  sub_FFFF1684(1610629120, 1610621004, 44, a4);
  sub_FFFF1688(1610621004, 0, 0x2Cu);
  sub_FFFF1688((int)&v5, 0, 8u);
  v5 = 44;
  v6 = 512;
  return sub_FFFF18EC((unsigned __int16 *)&v5);
}

//----- (FFFF1BCC) --------------------------------------------------------
int __fastcall sub_FFFF1BCC(_BYTE *a1, int a2, unsigned int a3)
{
  signed int v3; // r4
  unsigned __int8 *v4; // r7
  unsigned int v5; // r8
  unsigned int v6; // r6
  int result; // r0
  _BYTE *v8; // r4
  unsigned int v9; // r5
  signed int v10; // r0
  int v11; // r1
  int v12; // r2
  unsigned int v13; // r3
  int v14; // [sp+4h] [bp-2Ch]

  v14 = a2;
  v3 = 0;
  v4 = a1;
  v5 = a3;
  trace_write(16);
  v6 = 0;
LABEL_8:
  if ( v6 >= v5 )
  {
    trace_write(64);
    return v3;
  }
  nand_stuffs_1();
  result = sub_FFFF176E();
  if ( result )
    return result;
  v8 = (_BYTE *)(5 * v6 + v14);
  sub_FFFF1688((int)v4, 0, 0xCu);
  v9 = 0;
  v4[2] = v8[3];
  v4[1] = v8[2];
  v4[3] = v8[4];
  v4[4] = v8[1];
  while ( 1 )
  {
    v10 = sub_FFFF1940(v4, v9);
    v3 = v10;
    if ( v10 )
    {
      if ( v10 == 2 )
        goto LABEL_7;
      goto LABEL_6;
    }
    v3 = sub_FFFF1B8C(0, v11, v12, v13);
    if ( !v3
      && MEMORY[0x60002034] == 0xAA55A5A5
      && MEMORY[0x60002020] == sub_FFFF1692((unsigned __int16 *)0x60002024, 476)
      && sub_FFFF1B5C((int)v4) )
    {
      break;
    }
LABEL_6:
    v9 += 0x4000;
    if ( v9 >= 0xC000 )
    {
LABEL_7:
      ++v6;
      goto LABEL_8;
    }
  }
  trace_write(32);
  return 0;
}

//----- (FFFF1C84) --------------------------------------------------------
signed int __fastcall sub_FFFF1C84(unsigned __int8 *a1, int a2, int a3)
{
  unsigned __int8 *v3; // r8
  unsigned int v4; // r5
  int v5; // r7
  int v6; // r6
  int v7; // r10
  unsigned int v8; // r4
  signed int result; // r0
  unsigned int v10; // r3

  v3 = a1;
  v4 = 0;
  v5 = a2 << 14;
  v6 = 0x40000000;
  v7 = a3;
  v8 = *((unsigned __int16 *)a1 + 5) * *a1;
  while ( 1 )
  {
    result = sub_FFFF1812(v3, v5);
    if ( result == 2 || v7 && result == 5 )
      break;
    sub_FFFF1FD4(v6, 1610620928, v8, v10);
    v4 += v8;
    v5 += v8;
    v6 += v8;
    if ( v4 >= 0x4000 )
      return 0;
  }
  return result;
}

//----- (FFFF1CD8) --------------------------------------------------------
signed int __fastcall nand_stuffs_2(int a1)
{
  unsigned int v1; // r4
  unsigned __int8 *v2; // r7
  signed int result; // r0
  signed int v4; // r0
  signed int v5; // r5
  int v6; // r0

  v1 = 0;
  v2 = (unsigned __int8 *)a1;
  trace_write(128);
  nand_stuffs_1();
  result = sub_FFFF176E();
  if ( result != 2 )
  {
    while ( 1 )
    {
      v4 = sub_FFFF1C84(v2, v1, 1);
      v5 = v4;
      if ( !v4 )
        break;
      if ( v4 == 2 )
      {
        v6 = 256;
        goto LABEL_8;
      }
      if ( v4 == 5 )
        trace_write(1024 << v1);
      v1 = (unsigned __int8)(v1 + 1);
      if ( v1 >= 3 )
        return sub_FFFF1C84(v2, 0, 0);
    }
    v6 = 512;
LABEL_8:
    trace_write(v6);
    result = v5;
  }
  return result;
}

//----- (FFFF1D74) --------------------------------------------------------
signed int clear_uart_fifo()
{
  signed int result; // r0

  result = 0x83000000;
  while ( MEMORY[0x8400000C] )                  // clear uart1 fifo
    ;
  while ( MEMORY[0x8300000C] )                  // clear uart0 fifo
    ;
  return result;
}

//----- (FFFF1DA0) --------------------------------------------------------
signed int __fastcall read_spl_from_nand(int a1, int a2, int a3, int a4)
{
  signed int v4; // r4
  signed int result; // r0
  int v6; // [sp+0h] [bp-18h]
  int v7; // [sp+4h] [bp-14h]
  int v8; // [sp+8h] [bp-10h]

  v7 = a3;
  v8 = a4;
  v4 = 1;
  if ( read_unknown_ctrl5_3() == 1
    && (!sub_FFFF1BCC(&v6, (int)&unk_40006020, 0xCu) || !sub_FFFF1BCC(&v6, (int)&unk_4000605C, 0x24u)) )
  {
    v4 = nand_stuffs_2((int)&v6);
    if ( !v4 )
      goto LABEL_13;
  }
  if ( !sub_FFFF1BCC(&v6, (int)&unk_4000605C, 0x24u) || !sub_FFFF1BCC(&v6, (int)&unk_40006020, 0xCu) )
    v4 = nand_stuffs_2((int)&v6);
  if ( v4 )
    result = 0;
  else
LABEL_13:
    result = 1;
  return result;
}

//----- (FFFF1E1C) --------------------------------------------------------
int __cdecl main()
{
  __int16 v0; // r0
  __int16 v1; // r1
  int v2; // r0
  unsigned int v3; // r3
  signed int *v4; // r0
  int v5; // r1
  unsigned __int16 *v6; // r2
  int v7; // r3
  unsigned int uboot_spl_read_size; // r0
  unsigned int maybe_remapped; // r0
  int v11; // r1
  int v12; // r2
  int v13; // r3
  signed int spl_read_success; // r5
  int v15; // r4
  int v16; // r6
  int secboot_enabled; // r0 MAPDST
  int v18; // r0
  int uart_download; // [sp+0h] [bp-8h]

  uart_download = 0;
  MEMORY[0x20000000] &= 0xFFFFEFFF;             // EMC request timeout enable
  maybe_remapped = read_unknown_ctrl5_1();
  if ( maybe_remapped )
  {
    trace_write(1);
    jump_to(0);
    while ( 1 )
      ;
  }
  do
    ++maybe_remapped;
  while ( maybe_remapped < 0xA );
  platform_init();
  clear_uart_fifo();
  sub_FFFF1688((int)&word_40007E8C, 0, 0x18u);
  byte_40007E90 = 0;
  dword_40006018 = 0;
  dword_4000601C = 0;
  dword_40006010 = get_timer_tick();
  if ( is_booting_from_emmc() )
    spl_read_success = (unsigned __int8)read_spl_from_emmc();
  else
    spl_read_success = read_spl_from_nand(0, v11, v12, v13);
  dword_40006014 = 0x83000000;
  if ( (unsigned int)(get_timer_tick() - dword_40006010) < 0x14 )
    sleep();
  v15 = MEMORY[0x87000008] & 1;                 // detect keypad pressed
  v16 = MEMORY[0x8700002C] & 0x77;              // 0x8700002C keypad key status, 0x77 == volume down pressed
  if ( maybe_if_allow_uart_download() != 1 )
  {
    if ( !v15 || v16 )                          // key is not pressed
    {
      disable_keypad();
      check_uart_download((int)&uart_download); // then check uart
      goto LABEL_12;
    }
    disable_keypad();
  }
  v18 = maybe_check_usb_download();
  maybe_usb_download_related_2(v18);
LABEL_12:
  if ( BYTE1(uart_download) != 1 )              // if not going to enter uart download mode
  {
    secboot_enabled = CheckSecureBootEnable();
    if ( spl_read_success != 1 )
    {
      disable_nfc();
      while ( 1 )
        ;
    }
    trace_write(0x2000);
    if ( is_booting_from_emmc() )
      uboot_spl_read_size = 0x6000;             // 24kb
    else
      uboot_spl_read_size = 0x4000;             // 16kb
    if ( !secboot_enabled || HashVerify(0x40000000, uboot_spl_read_size >> 2) )
    {
      jump_to(0x40000000);                      // Jump to SPL !
      while ( 1 )
        ;
    }
    while ( 1 )
      ;
  }
  disable_keypad();
  trace_write(8);
  dword_40006018 = (int)&INIT_STACK;
  dword_4000601C = (int)&unk_40007A8C;
  sub_FFFF1688((int)&dword_40007EA4, 0, 0x20u);
  sub_FFFF0BEE();
  v0 = sub_FFFF23BC(0x81u);
  *(_WORD *)dword_40006018 = v0;
  v1 = sub_FFFF23BC(6u);
  v2 = dword_40006018;
  *(_WORD *)(dword_40006018 + 2) = v1;
  sub_FFFF1684(v2 + 4, (int)"SPRD3", 6, v3);
  v4 = sub_FFFF0C1E((unsigned __int8 *)dword_40006018, 12);
  sub_FFFF19F0((int)v4, v5, v6, v7);
}
// 40006010: using guessed type int dword_40006010;
// 40006014: using guessed type int dword_40006014;
// 40006018: using guessed type int dword_40006018;
// 4000601C: using guessed type int dword_4000601C;
// 40007E8C: using guessed type __int16 word_40007E8C;
// 40007E90: using guessed type char byte_40007E90;
// 40007EA4: using guessed type int dword_40007EA4;

//----- (FFFF1EEE) --------------------------------------------------------
int sub_FFFF1EEE()
{
  if ( byte_40007E90 != 1 )
  {
    sub_FFFF19D4(0x80u);
    byte_40007E90 = 1;
  }
  return sub_FFFF1688((int)&word_40007E8C, 0, 0x18u);
}
// 40007E8C: using guessed type __int16 word_40007E8C;
// 40007E90: using guessed type char byte_40007E90;

//----- (FFFF1F12) --------------------------------------------------------
signed int *__fastcall sub_FFFF1F12(int a1)
{
  int v1; // r5
  unsigned int v2; // r4
  unsigned int v3; // r0

  v1 = a1;
  v2 = sub_FFFF23C4(*(_DWORD *)(a1 + 4));
  v3 = sub_FFFF23C4(*(_DWORD *)(v1 + 8));
  dword_40007E9C = v2;
  dword_40007EA0 = v2;
  dword_40007E94 = v3;
  return sub_FFFF19D4(0x80u);
}
// 40007E94: using guessed type int dword_40007E94;
// 40007E9C: using guessed type int dword_40007E9C;
// 40007EA0: using guessed type int dword_40007EA0;

//----- (FFFF1F36) --------------------------------------------------------
signed int *__fastcall sub_FFFF1F36(int a1)
{
  int v1; // r5
  int v2; // r6
  unsigned int v3; // r3

  v1 = a1;
  v2 = sub_FFFF23BC(*(unsigned __int16 *)(a1 + 2));
  sub_FFFF1684(dword_40007EA0, v1 + 4, v2, v3);
  dword_40007EA0 += v2;
  dword_40007E98 += v2;
  return sub_FFFF19D4(0x80u);
}
// 40007E98: using guessed type int dword_40007E98;
// 40007EA0: using guessed type int dword_40007EA0;

//----- (FFFF1F64) --------------------------------------------------------
signed int *sub_FFFF1F64()
{
  unsigned int v0; // r0

  if ( dword_40007E98 == dword_40007E94 )
  {
    word_40007E8C = 143;
    v0 = 128;
  }
  else
  {
    byte_40007E90 = 5;
    v0 = 139;
  }
  return sub_FFFF19D4(v0);
}
// 40007E8C: using guessed type __int16 word_40007E8C;
// 40007E90: using guessed type char byte_40007E90;
// 40007E94: using guessed type int dword_40007E94;
// 40007E98: using guessed type int dword_40007E98;

//----- (FFFF1F7E) --------------------------------------------------------
int __fastcall sub_FFFF1F7E(int a1, int a2)
{
  sub_FFFF19D4(0x80u);
  return jump_to(dword_40007E9C);
}
// 40007E9C: using guessed type int dword_40007E9C;

//----- (FFFF1F94) --------------------------------------------------------
signed int sub_FFFF1F94()
{
  return 6;
}

//----- (FFFF1FA0) --------------------------------------------------------
int __fastcall sub_FFFF1FA0(_BYTE *a1, unsigned int a2)
{
  _BYTE *v2; // r3
  int result; // r0
  unsigned int v4; // r2
  bool v5; // nf
  bool v6; // cf

  v2 = a1;
  result = 0;
  while ( 1 )
  {
    v6 = a2-- >= 1;
    if ( !v6 )
      break;
    v4 = 128;
    do
    {
      v5 = result << 16 < 0;
      result = 2 * result & 0xFFFF;
      if ( v5 )
        result ^= 0x1021u;
      if ( *v2 & (unsigned __int8)v4 )
        result ^= 0x1021u;
      v4 >>= 1;
    }
    while ( v4 );
    ++v2;
  }
  return result;
}

//----- (FFFF1FD0) --------------------------------------------------------
int __fastcall sub_FFFF1FD0(int a1, int a2, int a3, unsigned int a4)
{
  return sub_FFFF1FD4(a1, a2, a3, a4);
}

//----- (FFFF1FD4) --------------------------------------------------------
int __fastcall sub_FFFF1FD4(int result, int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // r12
  char v5; // r3
  char v6; // t1
  bool v7; // cf
  bool v8; // zf
  unsigned int v9; // r2
  char v10; // t1
  char v11; // t1
  unsigned int v12; // r1
  unsigned int v13; // t1
  unsigned int v14; // r3
  unsigned int v15; // t1
  unsigned int v16; // r3
  unsigned int v17; // t1
  unsigned int v18; // r3
  unsigned int v19; // t1
  unsigned __int8 v20; // cf
  bool v21; // nf
  signed int v22; // r2
  char *v23; // r1
  char v24; // t1
  char v25; // t1
  _BYTE *v26; // r0

  if ( a3 > 3 )
  {
    v4 = result & 3;
    if ( result & 3 )
    {
      v6 = *(_BYTE *)a2++;
      v5 = v6;
      v7 = v4 >= 2;
      v8 = v4 == 2;
      v9 = a3 + v4;
      if ( v4 <= 2 )
      {
        v10 = *(_BYTE *)a2++;
        LOBYTE(v4) = v10;
      }
      *(_BYTE *)result++ = v5;
      if ( !v7 )
      {
        v11 = *(_BYTE *)a2++;
        v5 = v11;
      }
      if ( v8 || !v7 )
        *(_BYTE *)result++ = v4;
      a3 = v9 - 4;
      if ( !v7 )
        *(_BYTE *)result++ = v5;
    }
    a4 = a2 & 3;
    if ( !(a2 & 3) )
      return (int)sub_FFFF20A8((_DWORD *)result, (int *)a2, a3, 0);
    v7 = a3 >= 4;
    a3 -= 4;
    if ( v7 )
    {
      v13 = *(_DWORD *)(a2 - a4);
      v12 = a2 - a4;
      v4 = v13;
      if ( a4 == 2 )
      {
        do
        {
          v16 = v4 >> 16;
          v17 = *(_DWORD *)(v12 + 4);
          v12 += 4;
          v4 = v17;
          v7 = a3 >= 4;
          a3 -= 4;
          a4 = v16 | (v17 << 16);
          *(_DWORD *)result = a4;
          result += 4;
        }
        while ( v7 );
        a2 = v12 + 2;
      }
      else if ( a4 > 2 )
      {
        do
        {
          v18 = v4 >> 24;
          v19 = *(_DWORD *)(v12 + 4);
          v12 += 4;
          v4 = v19;
          v7 = a3 >= 4;
          a3 -= 4;
          a4 = v18 | (v19 << 8);
          *(_DWORD *)result = a4;
          result += 4;
        }
        while ( v7 );
        a2 = v12 + 3;
      }
      else
      {
        do
        {
          v14 = v4 >> 8;
          v15 = *(_DWORD *)(v12 + 4);
          v12 += 4;
          v4 = v15;
          v7 = a3 >= 4;
          a3 -= 4;
          a4 = v14 | (v15 << 24);
          *(_DWORD *)result = a4;
          result += 4;
        }
        while ( v7 );
        a2 = v12 + 1;
      }
    }
  }
  v20 = __CFSHL__(a3, 31);
  v22 = a3 << 31;
  v21 = v22 < 0;
  if ( v20 )
  {
    v24 = *(_BYTE *)a2;
    v23 = (char *)(a2 + 1);
    LOBYTE(a4) = v24;
    v25 = *v23;
    a2 = (int)(v23 + 1);
    LOBYTE(v4) = v25;
  }
  if ( v22 < 0 )
    LOBYTE(v22) = *(_BYTE *)a2;
  if ( v20 )
  {
    *(_BYTE *)result = a4;
    v26 = (_BYTE *)(result + 1);
    *v26 = v4;
    result = (int)(v26 + 1);
  }
  if ( v21 )
    *(_BYTE *)result++ = v22;
  return result;
}

//----- (FFFF20A8) --------------------------------------------------------
_DWORD *__fastcall sub_FFFF20A8(_DWORD *result, int *a2, unsigned int a3, int a4)
{
  unsigned int i; // r2
  int *v5; // r1
  int v6; // r3
  int v7; // r4
  int v8; // r12
  int v9; // lr
  int *v10; // r0
  int v11; // r4
  int v12; // r12
  int v13; // lr
  int v14; // r4
  int v15; // r12
  int v16; // lr
  int v17; // r4
  int v18; // t1
  bool v19; // cf
  bool v20; // nf
  signed int v21; // r2
  __int16 v22; // t1

  v19 = a3 >= 0x20;
  for ( i = a3 - 32; v19; result = v10 + 4 )
  {
    v6 = *a2;
    v7 = a2[1];
    v8 = a2[2];
    v9 = a2[3];
    v5 = a2 + 4;
    v19 = i >= 0x20;
    i -= 32;
    *result = v6;
    result[1] = v7;
    result[2] = v8;
    result[3] = v9;
    v10 = result + 4;
    a4 = *v5;
    v11 = v5[1];
    v12 = v5[2];
    v13 = v5[3];
    a2 = v5 + 4;
    *v10 = a4;
    v10[1] = v11;
    v10[2] = v12;
    v10[3] = v13;
  }
  if ( __CFSHL__(i, 28) )
  {
    a4 = *a2;
    v14 = a2[1];
    v15 = a2[2];
    v16 = a2[3];
    a2 += 4;
    *result = a4;
    result[1] = v14;
    result[2] = v15;
    result[3] = v16;
    result += 4;
  }
  if ( ((i << 28) & 0x80000000) != 0 )
  {
    a4 = *a2;
    v17 = a2[1];
    a2 += 2;
    *result = a4;
    result[1] = v17;
    result += 2;
  }
  if ( __CFSHL__(i, 30) )
  {
    v18 = *a2;
    ++a2;
    LOWORD(a4) = v18;
    *result = v18;
    ++result;
  }
  if ( i << 30 )
  {
    v19 = __CFSHL__(i, 31);
    v21 = i << 31;
    v20 = v21 < 0;
    if ( v19 )
    {
      v22 = *(_WORD *)a2;
      a2 = (int *)((char *)a2 + 2);
      LOWORD(a4) = v22;
    }
    if ( v21 < 0 )
      LOBYTE(v21) = *(_BYTE *)a2;
    if ( v19 )
    {
      *(_WORD *)result = a4;
      result = (_DWORD *)((char *)result + 2);
    }
    if ( v20 )
    {
      *(_BYTE *)result = v21;
      result = (_DWORD *)((char *)result + 1);
    }
  }
  return result;
}

//----- (FFFF21AC) --------------------------------------------------------
void __fastcall sub_FFFF21AC(unsigned int a1, unsigned int a2)
{
  if ( (a2 & 0x80000000 & 0x80000000) != 0 )
    a2 = -a2;
  if ( (a1 & 0x80000000) != 0 )
    a1 = -a1;
  if ( a1 >> 4 < a2 )
    JUMPOUT(&loc_FFFF223C);
  JUMPOUT(a1 >> 8, a2, &loc_FFFF21CC);
  JUMPOUT(&loc_FFFF220C);
}

//----- (FFFF22E0) --------------------------------------------------------
_DWORD *__fastcall sub_FFFF22E0(_DWORD *result, unsigned int a2, int a3)
{
  bool v3; // cf
  unsigned int v4; // r1
  int *v5; // r0
  signed int v6; // r1
  int v7; // r1

  v3 = a2 >= 0x20;
  v4 = a2 - 32;
  do
  {
    if ( !v3 )
      break;
    *result = a3;
    result[1] = a3;
    result[2] = a3;
    result[3] = a3;
    v5 = result + 4;
    *v5 = a3;
    v5[1] = a3;
    v5[2] = a3;
    v5[3] = a3;
    result = v5 + 4;
    v3 = v4 >= 0x20;
    v4 -= 32;
  }
  while ( v3 );
  v3 = __CFSHL__(v4, 28);
  v6 = v4 << 28;
  if ( v3 )
  {
    *result = a3;
    result[1] = a3;
    result[2] = a3;
    result[3] = a3;
    result += 4;
  }
  if ( v6 < 0 )
  {
    *result = a3;
    result[1] = a3;
    result += 2;
  }
  v3 = __CFSHL__(v6, 2);
  v7 = 4 * v6;
  if ( v3 )
  {
    *result = a3;
    ++result;
  }
  if ( v7 )
  {
    if ( v7 < 0 )
    {
      *(_WORD *)result = a3;
      result = (_DWORD *)((char *)result + 2);
    }
    if ( v7 & 0x40000000 )
    {
      *(_BYTE *)result = a3;
      result = (_DWORD *)((char *)result + 1);
    }
  }
  return result;
}

//----- (FFFF232A) --------------------------------------------------------
void *sub_FFFF232A()
{
  _DWORD *v0; // ST00_4
  void *result; // r0
  _DWORD *v2; // r12
  _DWORD *v3; // r12
  _DWORD *v4; // r12

  v0 = sub_FFFF2380();
  result = sub_FFFF0038();
  *v0 = 0;
  v0[1] = 0;
  v0[2] = 0;
  v0[3] = 0;
  v2 = v0 + 4;
  *v2 = 0;
  v2[1] = 0;
  v2[2] = 0;
  v2[3] = 0;
  v3 = v0 + 8;
  *v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  v3[3] = 0;
  v4 = v0 + 12;
  *v4 = 0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = 0;
  return result;
}

//----- (FFFF2380) --------------------------------------------------------
void *sub_FFFF2380()
{
  return &unk_40007EC4;
}

//----- (FFFF2388) --------------------------------------------------------
void *sub_FFFF2388()
{
  return &unk_40007EC8;
}

//----- (FFFF2390) --------------------------------------------------------
int __fastcall sub_FFFF2390(unsigned int a1, unsigned int a2)
{
  bool v2; // cf
  BOOL v3; // r2
  bool v4; // cf
  int v5; // r2
  bool v6; // cf
  bool v7; // cf
  int v8; // r2
  bool v9; // cf
  int v10; // r2
  bool v11; // cf
  bool v12; // cf
  unsigned int v14; // r1
  int v15; // r2
  char v16; // cf
  bool v17; // cf
  int v18; // r2
  bool v19; // cf
  int v20; // r2
  bool v21; // cf
  int v22; // r2
  bool v23; // cf
  int v24; // r2
  bool v25; // cf
  int v26; // r2
  bool v27; // cf
  int v28; // off
  bool v29; // cf
  int v30; // r2

  v30 = 0;
  if ( a1 >> 2 < a2 )
  {
LABEL_18:
    v12 = a1 >> 1 >= a2;
    if ( a1 >> 1 >= a2 )
      a1 -= 2 * a2;
    return v30 + v12 + v30 + (a1 >= a2) + v30 + v12 + v30;
  }
  if ( a1 >> 5 < a2 )
  {
LABEL_11:
    v7 = a1 >> 4 >= a2;
    if ( a1 >> 4 >= a2 )
      a1 -= 16 * a2;
    v8 = v30 + v7 + v30;
    v9 = a1 >> 3 >= a2;
    if ( a1 >> 3 >= a2 )
      a1 -= 8 * a2;
    v10 = v8 + v9 + v8;
    v11 = a1 >> 2 >= a2;
    if ( a1 >> 2 >= a2 )
      a1 -= 4 * a2;
    v30 = v10 + v11 + v10;
    goto LABEL_18;
  }
  if ( a1 >> 8 < a2 )
  {
    v2 = a1 >> 7 >= a2;
    if ( a1 >> 7 >= a2 )
      a1 -= a2 << 7;
    v3 = v2;
    v4 = a1 >> 6 >= a2;
    if ( a1 >> 6 >= a2 )
      a1 -= a2 << 6;
    v5 = v3 + v4 + v3;
    v6 = a1 >> 5 >= a2;
    if ( a1 >> 5 >= a2 )
      a1 -= 32 * a2;
    v30 = v5 + v6 + v5;
    goto LABEL_11;
  }
  v14 = a2 << 6;
  v15 = -67108864;
  if ( a1 >> 8 < v14 )
    goto LABEL_28;
  v14 <<= 6;
  v15 = -1048576;
  if ( a1 >> 8 < v14 )
    goto LABEL_28;
  v14 <<= 6;
  v15 = -16384;
  if ( a1 >> 8 >= v14 )
  {
    v14 <<= 6;
    v15 = -256;
  }
  v16 = v14 <= 0;
  if ( v14 <= 0 )
    return 0;
  do
  {
    if ( v16 )
      v14 >>= 6;
LABEL_28:
    v17 = a1 >> 7 >= v14;
    if ( a1 >> 7 >= v14 )
      a1 -= v14 << 7;
    v18 = v15 + v17 + v15;
    v19 = a1 >> 6 >= v14;
    if ( a1 >> 6 >= v14 )
      a1 -= v14 << 6;
    v20 = v18 + v19 + v18;
    v21 = a1 >> 5 >= v14;
    if ( a1 >> 5 >= v14 )
      a1 -= 32 * v14;
    v22 = v20 + v21 + v20;
    v23 = a1 >> 4 >= v14;
    if ( a1 >> 4 >= v14 )
      a1 -= 16 * v14;
    v24 = v22 + v23 + v22;
    v25 = a1 >> 3 >= v14;
    if ( a1 >> 3 >= v14 )
      a1 -= 8 * v14;
    v26 = v24 + v25 + v24;
    v27 = a1 >> 2 >= v14;
    if ( a1 >> 2 >= v14 )
      a1 -= 4 * v14;
    v28 = v27 + v26;
    v16 = __CFADD__(v27, v26) | __CFADD__(v26, v28);
    v15 = v26 + v28;
  }
  while ( v16 );
  v29 = a1 >> 1 >= v14;
  if ( a1 >> 1 >= v14 )
    a1 -= 2 * v14;
  return v15 + v29 + v15 + (a1 >= v14) + v15 + v29 + v15;
}

//----- (FFFF23B4) --------------------------------------------------------
int __fastcall jump_to(int a1)
{
  return jump_to(a1);
}

//----- (FFFF23BC) --------------------------------------------------------
unsigned int __fastcall sub_FFFF23BC(unsigned int a1)
{
  return __rev16(a1);
}

//----- (FFFF23C4) --------------------------------------------------------
unsigned int __fastcall sub_FFFF23C4(int a1)
{
  return __ROR4__(a1, 8) ^ (((a1 ^ __ROR4__(a1, 16)) & 0xFF00FFFF) >> 8);
}

//----- (FFFF23D8) --------------------------------------------------------
_DWORD *sub_FFFF23D8()
{
  _DWORD *result; // r0

  result = sub_FFFF2388();
  *result = 0;
  return result;
}

//----- (FFFF2484) --------------------------------------------------------
_DWORD *__fastcall sub_FFFF2484(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD *v4; // r7
  unsigned int *v5; // r4
  unsigned int *v6; // r5
  signed int v7; // r0
  unsigned int *v8; // r10
  int v9; // r9
  unsigned int *v10; // r8
  signed int v11; // r6
  int v12; // r3
  int v14; // [sp+0h] [bp-128h]

  v4 = a1;
  v5 = (unsigned int *)&v14;
  v6 = a1;
  v7 = 0;
  v8 = (unsigned int *)a3;
  v9 = a4;
  v10 = (unsigned int *)a2;
  do
    *(&v14 + v7++) = 0;
  while ( v7 < 65 );
  v11 = 0;
  do
  {
    sub_FFFF34A8(v5, v10, *v6);
    ++v6;
    sub_FFFF34A8(v5, v8, *v5 * v9);
    ++v11;
    ++v5;
  }
  while ( v11 < 32 );
  if ( !sub_FFFF3460(v5, (int *)v8) )
    v5 -= 32;
  return sub_FFFF20A8(v4, (int *)v5, 0x80u, v12);
}

//----- (FFFF2528) --------------------------------------------------------
_DWORD *__fastcall sub_FFFF2528(_DWORD *a1, unsigned int *a2, int a3)
{
  _DWORD *v3; // r6
  unsigned int *v4; // r4
  unsigned int *v5; // r8
  int v6; // r7
  signed int v7; // r0
  signed int v8; // r0
  signed int v9; // r5
  int v10; // r3
  int v12; // [sp+0h] [bp-120h]

  v3 = a1;
  v4 = (unsigned int *)&v12;
  v5 = a2;
  v6 = a3;
  v7 = 32;
  do
    *(&v12 + v7++) = 0;
  while ( v7 < 65 );
  v8 = 0;
  do
  {
    *(&v12 + v8) = v3[v8];
    ++v8;
  }
  while ( v8 < 32 );
  v9 = 0;
  do
  {
    sub_FFFF34A8(v4, v5, *v4 * v6);
    ++v9;
    ++v4;
  }
  while ( v9 < 32 );
  if ( !sub_FFFF3460(v4, (int *)v5) )
    v4 -= 32;
  return sub_FFFF20A8(v3, (int *)v4, 0x80u, v10);
}

//----- (FFFF25C8) --------------------------------------------------------
unsigned int __fastcall sub_FFFF25C8(unsigned int result)
{
  signed int v1; // r3
  unsigned int v2; // r4
  signed int v3; // r2
  signed int v4; // r1

  v1 = 1;
  v2 = result;
  v3 = 1;
  v4 = 0;
  do
  {
    if ( !(result & 1) )
    {
      result += v2;
      v1 |= v3;
    }
    ++v4;
    result >>= 1;
    if ( v4 >= 32 )
      result = v1;
    v3 *= 2;
  }
  while ( v4 < 32 );
  return result;
}

//----- (FFFF2604) --------------------------------------------------------
int __fastcall RSA_ModPower(int result, _DWORD *a2, int a3, int a4)
{
  bool v4; // zf
  _DWORD *v5; // r5
  unsigned int *v6; // r6
  int v7; // r9
  int v8; // r7
  unsigned int v9; // r4
  int v10; // r8
  signed int v11; // r0
  signed int v12; // r0
  unsigned int v13; // r4
  int i; // r9
  int v15; // [sp+0h] [bp-A0h]

  v5 = (_DWORD *)result;
  v4 = result == 0;
  v6 = a2;
  if ( result )
    v4 = a2 == 0;
  v7 = a3;
  v8 = a4;
  v9 = 2147483648;
  if ( !v4 && a3 )
  {
    v10 = sub_FFFF25C8(*a2);
    sub_FFFF2484(v5, v7, (int)v6, v10);
    v11 = 0;
    do
    {
      *(&v15 + v11) = v5[v11];
      ++v11;
    }
    while ( v11 < 32 );
    v12 = 0;
    do
    {
      if ( v8 & v9 )
        break;
      ++v12;
      v9 >>= 1;
    }
    while ( v12 < 32 );
    v13 = v9 >> 1;
    for ( i = v12 + 1; i < 32; ++i )
    {
      sub_FFFF2484(v5, (int)v5, (int)v6, v10);
      if ( v8 & v13 )
        sub_FFFF2484(v5, (int)&v15, (int)v6, v10);
      v13 >>= 1;
    }
    result = (int)sub_FFFF2528(v5, v6, v10);
  }
  return result;
}

//----- (FFFF26EC) --------------------------------------------------------
_DWORD *__fastcall MD5Init(_DWORD *result)
{
  if ( result )
  {
    *result = 0x67452301;
    result[1] = 0xEFCDAB89;
    result[2] = 0x98BADCFE;
    result[3] = 0x10325476;
    result[4] = 0;
  }
  return result;
}

//----- (FFFF2714) --------------------------------------------------------
int __fastcall sub_FFFF2714(int *a1, int *a2)
{
  int v2; // ST14_4
  int v3; // ST18_4
  int v4; // ST1C_4
  int v5; // r6
  int v6; // ST20_4
  int v7; // ST24_4
  int v8; // r4
  int v9; // r12
  int v10; // ST28_4
  int v11; // r5
  int v12; // ST2C_4
  int v13; // r3
  int v14; // r5
  int v15; // ST30_4
  int v16; // r7
  int v17; // ST38_4
  int v18; // r4
  int v19; // r2
  int v20; // r12
  int v21; // r3
  int v22; // ST40_4
  int v23; // r5
  int v24; // ST44_4
  int v25; // r4
  int v26; // ST48_4
  int v27; // r2
  int v28; // ST4C_4
  int v29; // r3
  int v30; // lr
  int v31; // r5
  int v32; // r8
  int v33; // r4
  int v34; // r9
  int v35; // r2
  int v36; // r0
  int v37; // r3
  int v38; // r5
  int v39; // r4
  int v40; // r2
  int v41; // r3
  int v42; // r5
  int v43; // r4
  int v44; // r2
  int v45; // r3
  int v46; // r5
  int v47; // r4
  int v48; // r2
  int v49; // r3
  int v50; // r5
  int v51; // r4
  int v52; // r2
  int v53; // r3
  int v54; // r5
  int v55; // r4
  int v56; // r2
  int v57; // r3
  int v58; // r5
  int v59; // r4
  int v60; // r2
  int v61; // r3
  int v62; // r5
  int v63; // r4
  int v64; // r2
  int v65; // r3
  int v66; // r5
  int v67; // r4
  int v68; // r2
  int v69; // r3
  int v70; // r5
  int v71; // r4
  int v72; // r2
  int v73; // r3
  int v74; // r5
  int v75; // r4
  int v76; // r2
  int v77; // r3
  int v78; // r5
  int v79; // r4
  int v80; // r2
  int v81; // r3
  int v82; // r0
  int v83; // r4
  int v84; // r2
  int v85; // r3
  int result; // r0

  v2 = a2[1];
  v3 = a2[2];
  v4 = a2[3];
  v5 = *a1;
  v6 = *a2;
  v7 = a1[1];
  v8 = v2 + __ROR4__(*a2 + (v2 & v3 | v4 & ~v2) + *a1 - 680876936, 25);
  v9 = v8 + __ROR4__(v4 + (v8 & v2 | v3 & ~v8) + v7 - 389564586, 20);
  v10 = a1[2];
  v11 = a1[3];
  v12 = v11;
  v13 = v9 + __ROR4__(v3 + v10 + (v9 & v8 | v2 & ~v9) + 606105819, 15);
  v14 = v13 + __ROR4__(v2 + v11 + (v13 & v9 | v8 & ~v13) - 1044525330, 10);
  v15 = a1[4];
  v16 = a1[5];
  v17 = a1[6];
  v18 = v14 + __ROR4__(v15 + (v14 & v13 | v9 & ~v14) + v8 - 176418897, 25);
  v19 = v18 + __ROR4__(v9 + (v18 & v14 | v13 & ~v18) + v16 + 1200080426, 20);
  v20 = a1[7];
  v21 = v19 + __ROR4__(v13 + (v19 & v18 | v14 & ~v19) + v17 - 1473231341, 15);
  v22 = a1[8];
  v23 = v21 + __ROR4__(v14 + (v21 & v19 | v18 & ~v21) + v20 - 45705983, 10);
  v24 = a1[9];
  v25 = v23 + __ROR4__(v18 + v22 + (v23 & v21 | v19 & ~v23) + 1770035416, 25);
  v26 = a1[10];
  v27 = v25 + __ROR4__(v19 + v24 + (v25 & v23 | v21 & ~v25) - 1958414417, 20);
  v28 = a1[11];
  v29 = v27 + __ROR4__(v21 + (v27 & v25 | v23 & ~v27) + v26 - 42063, 15);
  v30 = a1[12];
  v31 = v29 + __ROR4__(v23 + (v29 & v27 | v25 & ~v29) + v28 - 1990404162, 10);
  v32 = a1[13];
  v33 = v31 + __ROR4__(v25 + (v31 & v29 | v27 & ~v31) + v30 + 1804603682, 25);
  v34 = a1[14];
  v35 = v33 + __ROR4__(v27 + (v33 & v31 | v29 & ~v33) + v32 - 40341101, 20);
  v36 = a1[15];
  v37 = v35 + __ROR4__(v29 + (v35 & v33 | v31 & ~v35) + v34 - 1502002290, 15);
  v38 = v37 + __ROR4__(v31 + (v37 & v35 | v33 & ~v37) + v36 + 1236535329, 10);
  v39 = v38 + __ROR4__(v33 + v7 + (v38 & v35 | v37 & ~v35) - 165796510, 27);
  v40 = v39 + __ROR4__(v35 + v17 + (v39 & v37 | v38 & ~v37) - 1069501632, 23);
  v41 = v40 + __ROR4__(v37 + v28 + (v40 & v38 | v39 & ~v38) + 643717713, 18);
  v42 = v41 + __ROR4__(v38 + (v40 & ~v39 | v41 & v39) + v5 - 373897302, 12);
  v43 = v42 + __ROR4__(v39 + (v41 & ~v40 | v42 & v40) + v16 - 701558691, 27);
  v44 = v43 + __ROR4__(v40 + v26 + (v43 & v41 | v42 & ~v41) + 38016083, 23);
  v45 = v44 + __ROR4__(v41 + (v43 & ~v42 | v44 & v42) + v36 - 660478335, 18);
  v46 = v45 + __ROR4__(v42 + v15 + (v45 & v43 | v44 & ~v43) - 405537848, 12);
  v47 = v46 + __ROR4__(v43 + v24 + (v46 & v44 | v45 & ~v44) + 568446438, 27);
  v48 = v47 + __ROR4__(v44 + (v46 & ~v45 | v47 & v45) + v34 - 1019803690, 23);
  v49 = v48 + __ROR4__(v45 + v12 + (v48 & v46 | v47 & ~v46) - 187363961, 18);
  v50 = v49 + __ROR4__(v46 + v22 + (v49 & v47 | v48 & ~v47) + 1163531501, 12);
  v51 = v50 + __ROR4__(v47 + (v49 & ~v48 | v50 & v48) + v32 - 1444681467, 27);
  v52 = v51 + __ROR4__(v48 + v10 + (v51 & v49 | v50 & ~v49) - 51403784, 23);
  v53 = v52 + __ROR4__(v49 + (v51 & ~v50 | v52 & v50) + v20 + 1735328473, 18);
  v54 = v53 + __ROR4__(v50 + (v52 & ~v51 | v53 & v51) + v30 - 1926607734, 12);
  v55 = v54 + __ROR4__(v51 + (v54 ^ v53 ^ v52) + v16 - 378558, 28);
  v56 = v55 + __ROR4__(v52 + v22 + (v55 ^ v54 ^ v53) - 2022574463, 21);
  v57 = v56 + __ROR4__(v53 + v28 + (v56 ^ v55 ^ v54) + 1839030562, 16);
  v58 = v57 + __ROR4__(v54 + (v57 ^ v56 ^ v55) + v34 - 35309556, 9);
  v59 = v58 + __ROR4__(v55 + v7 + (v58 ^ v57 ^ v56) - 1530992060, 28);
  v60 = v59 + __ROR4__(v56 + v15 + (v59 ^ v58 ^ v57) + 1272893353, 21);
  v61 = v60 + __ROR4__(v57 + (v60 ^ v59 ^ v58) + v20 - 155497632, 16);
  v62 = v61 + __ROR4__(v58 + v26 + (v61 ^ v60 ^ v59) - 1094730640, 9);
  v63 = v62 + __ROR4__(v59 + (v62 ^ v61 ^ v60) + v32 + 681279174, 28);
  v64 = v63 + __ROR4__(v60 + (v63 ^ v62 ^ v61) + v5 - 358537222, 21);
  v65 = v64 + __ROR4__(v61 + v12 + (v64 ^ v63 ^ v62) - 722521979, 16);
  v66 = v65 + __ROR4__(v62 + v17 + (v65 ^ v64 ^ v63) + 76029189, 9);
  v67 = v66 + __ROR4__(v63 + v24 + (v66 ^ v65 ^ v64) - 640364487, 28);
  v68 = v67 + __ROR4__(v64 + (v67 ^ v66 ^ v65) + v30 - 421815835, 21);
  v69 = v68 + __ROR4__(v65 + (v68 ^ v67 ^ v66) + v36 + 530742520, 16);
  v70 = v69 + __ROR4__(v66 + v10 + (v69 ^ v68 ^ v67) - 995338651, 9);
  v71 = v70 + __ROR4__(v67 + v5 + ((~v68 | v70) ^ v69) - 198630844, 26);
  v72 = v71 + __ROR4__(v68 + v20 + ((~v69 | v71) ^ v70) + 1126891415, 22);
  v73 = v72 + __ROR4__(v69 + ((~v70 | v72) ^ v71) + v34 - 1416354905, 17);
  v74 = v73 + __ROR4__(v70 + ((~v71 | v73) ^ v72) + v16 - 57434055, 11);
  v75 = v74 + __ROR4__(v71 + ((~v72 | v74) ^ v73) + v30 + 1700485571, 26);
  v76 = v75 + __ROR4__(v72 + v12 + ((~v73 | v75) ^ v74) - 1894986606, 22);
  v77 = v76 + __ROR4__(v73 + v26 + ((~v74 | v76) ^ v75) - 1051523, 17);
  v78 = v77 + __ROR4__(v74 + v7 + ((~v75 | v77) ^ v76) - 2054922799, 11);
  v79 = v78 + __ROR4__(v75 + v22 + ((~v76 | v78) ^ v77) + 1873313359, 26);
  v80 = v79 + __ROR4__(v36 + ((~v77 | v79) ^ v78) + v76 - 30611744, 22);
  v81 = v80 + __ROR4__(v17 + ((~v78 | v80) ^ v79) + v77 - 1560198380, 17);
  v82 = v81 + __ROR4__(v78 + ((~v79 | v81) ^ v80) + v32 + 1309151649, 11);
  v83 = v82 + __ROR4__(v15 + ((~v80 | v82) ^ v81) + v79 - 145523070, 26);
  v84 = v83 + __ROR4__(v80 + v28 + ((~v81 | v83) ^ v82) - 1120210379, 22);
  v85 = v84 + __ROR4__(v81 + v10 + ((~v82 | v84) ^ v83) + 718787259, 17);
  a2[3] = v84 + v4;
  *a2 = v6 + v83;
  a2[2] = v3 + v85;
  result = v85 + __ROR4__(v24 + ((~v83 | v85) ^ v84) + v82 - 343485551, 11) + v2;
  a2[1] = result;
  return result;
}

//----- (FFFF3108) --------------------------------------------------------
int __fastcall sub_FFFF3108(int result, int a2, int *a3)
{
  int *v3; // r6
  int *v4; // r5
  int v5; // r4

  v3 = (int *)result;
  v4 = a3;
  if ( !(a2 & 0xF) )
  {
    v5 = a2;
    result = a3[4] + a2;
    for ( a3[4] = result; v5; v3 += 16 )
    {
      result = sub_FFFF2714(v3, v4);
      v5 -= 16;
    }
  }
  return result;
}

//----- (FFFF314C) --------------------------------------------------------
int __fastcall MD5Final(int *a1, unsigned int a2, int a3)
{
  int *v3; // r6
  unsigned int v4; // r4
  int *v5; // r9
  unsigned int v6; // r8
  unsigned int v7; // r0
  unsigned int v8; // r1
  int v9; // t1
  unsigned int v10; // r0
  int v12; // [sp+0h] [bp-60h]
  unsigned int v13; // [sp+38h] [bp-28h]

  v3 = a1;
  v4 = a2;
  v5 = (int *)a3;
  v6 = *(_DWORD *)(a3 + 16) + a2;
  if ( a2 >= 0x10 )
  {
    sub_FFFF3108((int)a1, a2 & 0xFFFFFFF0, (int *)a3);
    v7 = v4 & 0xFFFFFFF0;
    v4 &= 0xFu;
    v3 += v7;
  }
  v8 = 0;
  do
  {
    if ( v8 >= v4 )
    {
      *(&v12 + v8) = 0;
    }
    else
    {
      v9 = *v3;
      ++v3;
      *(&v12 + v8) = v9;
    }
    ++v8;
  }
  while ( v8 < 0x10 );
  *(&v12 + v4) = 128;
  if ( v4 >= 0xE )
  {
    sub_FFFF3108((int)&v12, 16, v5);
    v10 = 0;
    do
      *(&v12 + v10++) = 0;
    while ( v10 < 0x10 );
  }
  v13 = 32 * v6;
  return sub_FFFF3108((int)&v12, 16, v5);
}

//----- (FFFF3204) --------------------------------------------------------
int efuse_get_timer_tick()
{
  int result; // r0

  do
    result = MEMORY[0x87003004];
  while ( MEMORY[0x87003004] != MEMORY[0x87003004] );
  return result;
}

//----- (FFFF3210) --------------------------------------------------------
int efuse_parameter_config_1()
{
  unsigned int v0; // r1
  int v1; // r5
  int result; // r0

  v0 = 0;
  MEMORY[0x8B000008] |= 0x80u;
  MEMORY[0x8B00004C] |= 0x10000000u;
  do
    ++v0;
  while ( v0 < 0x64 );
  MEMORY[0x8B00004C] &= 0xEFFFFFFF;
  MEMORY[0x89000010] |= 0x20000000u;
  v1 = efuse_get_timer_tick();
  result = efuse_get_timer_tick();
  MEMORY[0x89000010] |= 0x10000000u;
  MEMORY[0x89000010] |= 0x80000000;
  while ( result == v1 )
    result = efuse_get_timer_tick();
  return result;
}

//----- (FFFF3268) --------------------------------------------------------
unsigned int efuse_parameter_config_2()
{
  unsigned int result; // r0

  MEMORY[0x89000010] &= 0xEFFFFFFF;
  MEMORY[0x89000010] &= 0x7FFFFFFFu;
  MEMORY[0x89000010] &= 0xDFFFFFFF;
  result = MEMORY[0x8B000008] & 0xFFFFFF7F;
  MEMORY[0x8B000008] &= 0xFFFFFF7F;
  return result;
}

//----- (FFFF3292) --------------------------------------------------------
signed int __fastcall efuse_read(unsigned int a1, _DWORD *a2)
{
  _DWORD *v2; // r8
  int v3; // r6
  int v5; // r5
  int v6; // r7

  v2 = a2;
  v3 = 0;
  if ( a1 >= 9 )
    return 6;
  MEMORY[0x89000008] = a1 | (a1 << 16);
  MEMORY[0x8900000C] |= 2u;                     // EFUSE_RD_START, start reading efuse
  v5 = MEMORY[0x89000014] & 2;
  v6 = efuse_get_timer_tick();
  do
  {
    if ( v5 != 2 )
      goto LABEL_9;
    v5 = MEMORY[0x89000014] & 2;
  }
  while ( (unsigned int)(efuse_get_timer_tick() - v6) <= 2 );
  if ( v5 != 2 )
  {
LABEL_9:
    *v2 = MEMORY[0x89000000];
    return v3;
  }
  return 1;
}

//----- (FFFF32EE) --------------------------------------------------------
signed int __fastcall sub_FFFF32EE(unsigned int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-8h]

  v5 = a4;
  if ( efuse_read(a1, &v5) )
    return 1;
  if ( v5 >= 0 )
    return 13;
  return 14;
}

//----- (FFFF330A) --------------------------------------------------------
int __fastcall efuse_program_related(unsigned int a1, int a2, int a3, int a4)
{
  int v4; // r7
  unsigned int v5; // r5
  int result; // r0
  int v7; // r6
  int v8; // r8
  int v9; // r6
  int v10; // [sp+0h] [bp-20h]

  v10 = a4;
  v4 = a2;
  v5 = a1;
  if ( a1 >= 9 )
    return 6;
  result = sub_FFFF32EE(a1, a2, a3, a4);
  if ( result != 14 )
  {
    MEMORY[0x89000020] = 0x8810;                // EFUSE_MAGIC_NUMBER = 0x8810 , permitting efuse programming
    MEMORY[0x89000008] = v5 | (v5 << 16);
    MEMORY[0x89000004] = v4;
    MEMORY[0x89000010] |= 0x10000 << v5;
    MEMORY[0x8900000C] |= 1u;
    v7 = MEMORY[0x89000014] & 1;
    v8 = efuse_get_timer_tick();
    while ( v7 == 1 )
    {
      v7 = MEMORY[0x89000014] & 1;
      if ( (unsigned int)(efuse_get_timer_tick() - v8) > 3 )
      {
        if ( v7 == 1 )
        {
          MEMORY[0x89000020] = 0;
          return 2;
        }
        break;
      }
    }
    v9 = MEMORY[0x89000018] & (256 << v5);
    if ( efuse_read(v5, &v10) )
    {
      result = 4;
    }
    else if ( (v4 & 0x7FFFFFFF) == (v10 & 0x7FFFFFFF) )
    {
      if ( v9 )
        result = 9;
      else
        result = 0;
    }
    else if ( v9 )
    {
      result = 10;
    }
    else
    {
      result = 3;
    }
    MEMORY[0x89000020] = 0;
  }
  return result;
}

//----- (FFFF33BE) --------------------------------------------------------
signed int __fastcall sub_FFFF33BE(unsigned int a1, int a2, int a3, int a4)
{
  unsigned int v4; // r4
  signed int result; // r0
  int v6; // r2
  int v7; // r3
  int v8; // [sp+0h] [bp-10h]

  v8 = a4;
  v4 = a1;
  result = efuse_read(a1, &v8);
  if ( !result )
  {
    if ( v8 >= 0 )
      result = efuse_program_related(v4, v8 | 0x80000000, v6, v7);
    else
      result = 0;
  }
  return result;
}

//----- (FFFF33E4) --------------------------------------------------------
signed int __fastcall sub_FFFF33E4(int a1, int a2, int a3, int a4)
{
  unsigned int v4; // r4
  signed int result; // r0

  v4 = 1;
  do
  {
    result = sub_FFFF33BE(v4, a2, a3, a4);
    if ( result )
      break;
    ++v4;
  }
  while ( v4 <= 4 );
  return result;
}

//----- (FFFF33FA) --------------------------------------------------------
int __fastcall sub_FFFF33FA(int a1)
{
  unsigned int v1; // r4
  _DWORD *v2; // r5
  int result; // r0

  v1 = 1;
  v2 = (_DWORD *)a1;
  do
  {
    result = efuse_read(v1, v2);
    if ( result )
      break;
    ++v1;
    ++v2;
  }
  while ( v1 <= 4 );
  return result;
}

//----- (FFFF3416) --------------------------------------------------------
int __fastcall sub_FFFF3416(_DWORD *a1, int a2, int a3, int a4)
{
  unsigned int v4; // r4
  _DWORD *v5; // r5
  int result; // r0

  v4 = 1;
  v5 = a1;
  do
  {
    result = efuse_program_related(v4, *v5 & 0x7FFFFFFF, a3, a4);
    if ( result )
      break;
    ++v4;
    ++v5;
  }
  while ( v4 <= 4 );
  return result;
}

//----- (FFFF3436) --------------------------------------------------------
signed int __fastcall sub_FFFF3436(unsigned int a1, bool *a2)
{
  bool *v2; // r4
  signed int result; // r0
  unsigned int v4; // [sp+0h] [bp-10h]

  v2 = a2;
  v4 = 0;
  result = efuse_read(a1, &v4);
  if ( !result )
    *v2 = v4 >> 31 == 1;
  return result;
}

//----- (FFFF3460) --------------------------------------------------------
int __fastcall sub_FFFF3460(unsigned int *a1, int *a2)
{
  signed int v2; // r4
  unsigned int v7; // r2
  unsigned int v8; // r5
  unsigned int v9; // r7
  unsigned int v10; // r9
  int v11; // r3
  int v12; // r6
  int v13; // r8
  int v14; // r12
  int *v15; // r0
  int v16; // r2
  int v17; // t0
  int v18; // r5
  int v19; // t0
  int v20; // r7
  int v21; // t0
  int v22; // t0

  v2 = 8;
  __asm { MSR             CPSR_f, #0x20000000 }
  do
  {
    v7 = *a1;
    v8 = a1[1];
    v9 = a1[2];
    v10 = a1[3];
    v11 = *a2;
    v12 = a2[1];
    v13 = a2[2];
    v14 = a2[3];
    a2 += 4;
    v15 = (int *)(a1 - 32);
    v17 = v11 + !_CF;
    _CF = v7 >= v11 + (unsigned int)!_CF;
    v16 = v7 - v17;
    v19 = v12 + !_CF;
    _CF = v8 >= v12 + (unsigned int)!_CF;
    v18 = v8 - v19;
    v21 = v13 + !_CF;
    _CF = v9 >= v13 + (unsigned int)!_CF;
    v20 = v9 - v21;
    v22 = v14 + !_CF;
    _CF = v10 >= v14 + (unsigned int)!_CF;
    *v15 = v16;
    v15[1] = v18;
    v15[2] = v20;
    v15[3] = v10 - v22;
    a1 = (unsigned int *)(v15 + 36);
    --v2;
  }
  while ( v2 );
  return *a1 - !_CF;
}

//----- (FFFF34A8) --------------------------------------------------------
_DWORD *__fastcall sub_FFFF34A8(_DWORD *result, unsigned int *a2, unsigned int a3)
{
  signed int v3; // r5
  signed int v4; // r12
  unsigned int *v5; // r3
  _DWORD *v6; // r4
  unsigned int v11; // t1
  int v12; // r11
  unsigned __int64 v13; // r6
  int v14; // r9
  int v15; // off
  int v16; // r11
  int v17; // off
  int v18; // off

  v3 = 16;
  v4 = 2;
  v5 = a2;
  v6 = result;
  __asm { MSR             CPSR_f, #0 }
  do
  {
    do
    {
      v11 = *v5;
      v5 += 2;
      v12 = v6[1];
      v13 = a3 * (unsigned __int64)v11;
      v15 = _CF;
      _CF = __CFADD__(_CF, *v6) | __CFADD__((_DWORD)v13, _CF + *v6);
      v14 = v13 + v15 + *v6;
      v17 = _CF;
      _CF = __CFADD__(_CF, v12);
      v16 = v17 + v12;
      _CF |= __CFADD__(HIDWORD(v13), v16);
      *v6 = v14;
      v6[1] = HIDWORD(v13) + v16;
      v6 += 2;
      --v3;
    }
    while ( v3 );
    v3 = 16;
    v18 = _CF;
    _CF = __CFADD__(_CF, *v6);
    *v6 += v18;
    v6 -= 31;
    v5 -= 31;
    --v4;
  }
  while ( v4 );
  return result;
}

// ALL OK, 152 function(s) have been successfully decompiled
